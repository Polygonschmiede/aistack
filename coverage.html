
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>aistack: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">aistack/cmd/aistack/main.go (0.0%)</option>
				
				<option value="file1">aistack/internal/agent/agent.go (0.0%)</option>
				
				<option value="file2">aistack/internal/gpu/detector.go (88.2%)</option>
				
				<option value="file3">aistack/internal/gpu/nvml.go (6.2%)</option>
				
				<option value="file4">aistack/internal/gpu/toolkit.go (18.3%)</option>
				
				<option value="file5">aistack/internal/idle/engine.go (97.1%)</option>
				
				<option value="file6">aistack/internal/idle/executor.go (13.2%)</option>
				
				<option value="file7">aistack/internal/idle/state.go (78.1%)</option>
				
				<option value="file8">aistack/internal/idle/types.go (75.0%)</option>
				
				<option value="file9">aistack/internal/idle/window.go (98.2%)</option>
				
				<option value="file10">aistack/internal/logging/logger.go (73.3%)</option>
				
				<option value="file11">aistack/internal/metrics/collector.go (0.0%)</option>
				
				<option value="file12">aistack/internal/metrics/cpu_collector.go (23.9%)</option>
				
				<option value="file13">aistack/internal/metrics/gpu_collector.go (85.4%)</option>
				
				<option value="file14">aistack/internal/metrics/types.go (100.0%)</option>
				
				<option value="file15">aistack/internal/metrics/writer.go (75.0%)</option>
				
				<option value="file16">aistack/internal/services/health.go (94.4%)</option>
				
				<option value="file17">aistack/internal/services/localai.go (100.0%)</option>
				
				<option value="file18">aistack/internal/services/manager.go (21.1%)</option>
				
				<option value="file19">aistack/internal/services/network.go (71.4%)</option>
				
				<option value="file20">aistack/internal/services/ollama.go (100.0%)</option>
				
				<option value="file21">aistack/internal/services/openwebui.go (100.0%)</option>
				
				<option value="file22">aistack/internal/services/runtime.go (13.0%)</option>
				
				<option value="file23">aistack/internal/services/service.go (5.1%)</option>
				
				<option value="file24">aistack/internal/tui/model.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "path/filepath"
        "time"

        tea "github.com/charmbracelet/bubbletea"

        "aistack/internal/agent"
        "aistack/internal/gpu"
        "aistack/internal/logging"
        "aistack/internal/metrics"
        "aistack/internal/services"
        "aistack/internal/tui"
)

const version = "0.1.0-dev"

func main() <span class="cov0" title="0">{
        // Parse command line arguments
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                switch os.Args[1] </span>{
                case "agent":<span class="cov0" title="0">
                        runAgent()
                        return</span>
                case "idle-check":<span class="cov0" title="0">
                        runIdleCheck()
                        return</span>
                case "install":<span class="cov0" title="0">
                        runInstall()
                        return</span>
                case "start":<span class="cov0" title="0">
                        runServiceCommand("start")
                        return</span>
                case "stop":<span class="cov0" title="0">
                        runServiceCommand("stop")
                        return</span>
                case "status":<span class="cov0" title="0">
                        runStatus()
                        return</span>
                case "gpu-check":<span class="cov0" title="0">
                        runGPUCheck()
                        return</span>
                case "metrics-test":<span class="cov0" title="0">
                        runMetricsTest()
                        return</span>
                case "version":<span class="cov0" title="0">
                        fmt.Printf("aistack version %s\n", version)
                        return</span>
                case "help", "--help", "-h":<span class="cov0" title="0">
                        printUsage()
                        return</span>
                }
        }

        // Default: run TUI
        <span class="cov0" title="0">runTUI()</span>
}

// runTUI starts the interactive TUI mode
func runTUI() <span class="cov0" title="0">{
        // Initialize logger
        logger := logging.NewLogger(logging.LevelInfo)

        // Log app.started event
        startTime := time.Now()
        logger.Info("app.started", "Application started", map[string]interface{}{
                "version": version,
                "ts":      startTime.UTC().Format(time.RFC3339),
        })

        // Create and run the TUI
        p := tea.NewProgram(tui.NewModel())

        // Run the program and capture exit reason
        finalModel, err := p.Run()
        exitReason := "normal"

        if err != nil </span><span class="cov0" title="0">{
                exitReason = "error"
                logger.Error("app.error", "Application error", map[string]interface{}{
                        "error": err.Error(),
                })
                fmt.Fprintf(os.Stderr, "Error running TUI: %v\n", err)
                os.Exit(1)
        }</span>

        // Ensure we got our model type back
        <span class="cov0" title="0">_ = finalModel

        // Log app.exited event
        logger.Info("app.exited", "Application exited", map[string]interface{}{
                "ts":     time.Now().UTC().Format(time.RFC3339),
                "reason": exitReason,
        })</span>
}

// runAgent starts the background agent service (for systemd)
func runAgent() <span class="cov0" title="0">{
        // Setup logger for agent mode (structured JSON to journald)
        logger := logging.NewLogger(logging.LevelInfo)

        logger.Info("agent.mode", "Starting in agent mode", map[string]interface{}{
                "version": version,
        })

        // Create and run agent
        agentInstance := agent.NewAgent(logger)

        if err := agentInstance.Run(); err != nil </span><span class="cov0" title="0">{
                logger.Error("agent.error", "Agent error", map[string]interface{}{
                        "error": err.Error(),
                })
                os.Exit(1)
        }</span>
}

// runIdleCheck performs a single idle check (for timer-triggered runs)
func runIdleCheck() <span class="cov0" title="0">{
        logger := logging.NewLogger(logging.LevelInfo)

        if err := agent.IdleCheck(logger); err != nil </span><span class="cov0" title="0">{
                logger.Error("idle.error", "Idle check error", map[string]interface{}{
                        "error": err.Error(),
                })
                os.Exit(1)
        }</span>
}

// runInstall installs services based on profile or individual service
func runInstall() <span class="cov0" title="0">{
        logger := logging.NewLogger(logging.LevelInfo)

        // Get compose directory (relative to binary or default)
        composeDir := resolveComposeDir()

        manager, err := services.NewManager(composeDir, logger)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error initializing service manager: %v\n", err)
                os.Exit(1)
        }</span>

        // Check for --profile flag
        <span class="cov0" title="0">if len(os.Args) &gt; 2 </span><span class="cov0" title="0">{
                if os.Args[2] == "--profile" &amp;&amp; len(os.Args) &gt; 3 </span><span class="cov0" title="0">{
                        profile := os.Args[3]
                        fmt.Printf("Installing profile: %s\n", profile)
                        if err := manager.InstallProfile(profile); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error installing profile: %v\n", err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("Profile %s installed successfully\n", profile)
                        return</span>
                }

                // Install specific service
                <span class="cov0" title="0">serviceName := os.Args[2]
                service, err := manager.GetService(serviceName)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Installing service: %s\n", serviceName)
                if err := service.Install(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error installing service: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Service %s installed successfully\n", serviceName)
                return</span>
        }

        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "Usage: aistack install [--profile &lt;profile&gt;|&lt;service&gt;]\n")
        os.Exit(1)</span>
}

// runServiceCommand runs start/stop commands on services
func runServiceCommand(command string) <span class="cov0" title="0">{
        logger := logging.NewLogger(logging.LevelInfo)
        composeDir := resolveComposeDir()

        manager, err := services.NewManager(composeDir, logger)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error initializing service manager: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(os.Args) &lt; 3 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: aistack %s &lt;service&gt;\n", command)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">serviceName := os.Args[2]
        service, err := manager.GetService(serviceName)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">switch command </span>{
        case "start":<span class="cov0" title="0">
                fmt.Printf("Starting service: %s\n", serviceName)
                if err := service.Start(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error starting service: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Service %s started successfully\n", serviceName)</span>
        case "stop":<span class="cov0" title="0">
                fmt.Printf("Stopping service: %s\n", serviceName)
                if err := service.Stop(); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error stopping service: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Service %s stopped successfully\n", serviceName)</span>
        }
}

// runStatus displays status of all services
func runStatus() <span class="cov0" title="0">{
        logger := logging.NewLogger(logging.LevelInfo)
        composeDir := resolveComposeDir()

        manager, err := services.NewManager(composeDir, logger)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error initializing service manager: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">statuses, err := manager.StatusAll()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error getting status: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("Service Status:")
        fmt.Println("---------------")
        for _, status := range statuses </span><span class="cov0" title="0">{
                fmt.Printf("%-12s  State: %-10s  Health: %s\n",
                        status.Name, status.State, status.Health)
        }</span>
}

// runGPUCheck performs GPU detection and displays results
func runGPUCheck() <span class="cov0" title="0">{
        logger := logging.NewLogger(logging.LevelInfo)

        fmt.Println("Checking GPU and NVIDIA Stack...")
        fmt.Println()

        // Detect GPUs via NVML
        detector := gpu.NewDetector(logger)
        gpuReport := detector.DetectGPUs()

        // Display GPU report
        fmt.Println("=== GPU Detection Report ===")
        if !gpuReport.NVMLOk </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå NVML Status: FAILED\n")
                fmt.Printf("   Error: %s\n", gpuReport.ErrorMessage)
                fmt.Println()
                fmt.Println("üí° Hint: Install NVIDIA drivers to enable GPU support")
                fmt.Println("   https://docs.nvidia.com/datacenter/tesla/tesla-installation-notes/")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("‚úì NVML Status: OK\n")
                fmt.Printf("  Driver Version: %s\n", gpuReport.DriverVersion)
                fmt.Printf("  CUDA Version: %d\n", gpuReport.CUDAVersion)
                fmt.Printf("  GPU Count: %d\n", len(gpuReport.GPUs))
                fmt.Println()

                for _, gpu := range gpuReport.GPUs </span><span class="cov0" title="0">{
                        fmt.Printf("  GPU %d:\n", gpu.Index)
                        fmt.Printf("    Name: %s\n", gpu.Name)
                        fmt.Printf("    UUID: %s\n", gpu.UUID)
                        fmt.Printf("    Memory: %d MB\n", gpu.MemoryMB)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println()

        // Detect Container Toolkit
        toolkitDetector := gpu.NewToolkitDetector(logger)
        toolkitReport := toolkitDetector.DetectContainerToolkit()

        fmt.Println("=== NVIDIA Container Toolkit ===")
        if !toolkitReport.DockerSupport </span><span class="cov0" title="0">{
                fmt.Printf("‚ùå Docker GPU Support: NOT AVAILABLE\n")
                if toolkitReport.ErrorMessage != "" </span><span class="cov0" title="0">{
                        fmt.Printf("   Error: %s\n", toolkitReport.ErrorMessage)
                }</span>
                <span class="cov0" title="0">fmt.Println()
                fmt.Println("üí° Hint: Install NVIDIA Container Toolkit to enable GPU in containers")
                fmt.Println("   https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html")</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("‚úì Docker GPU Support: AVAILABLE\n")
                if toolkitReport.ToolkitVersion != "" </span><span class="cov0" title="0">{
                        fmt.Printf("  Toolkit Version: %s\n", toolkitReport.ToolkitVersion)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println()

        // Save detailed report if requested
        if len(os.Args) &gt; 2 &amp;&amp; os.Args[2] == "--save" </span><span class="cov0" title="0">{
                reportPath := "/tmp/gpu_report.json"
                if err := detector.SaveReport(gpuReport, reportPath); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Failed to save report: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">fmt.Printf("Detailed report saved to: %s\n", reportPath)</span>
        }
}

// runMetricsTest performs a test metrics collection
func runMetricsTest() <span class="cov0" title="0">{
        logger := logging.NewLogger(logging.LevelInfo)

        fmt.Println("Testing metrics collection...")
        fmt.Println()

        // Create collector with default config
        config := metrics.DefaultConfig()
        collector := metrics.NewCollector(config, logger)

        // Initialize
        if err := collector.Initialize(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to initialize metrics collector: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer collector.Shutdown()

        fmt.Println("=== Metrics Collection Test ===")
        fmt.Println("Collecting 3 samples with 5-second interval...")
        fmt.Println()

        // Collect 3 samples
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                sample, err := collector.CollectSample()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Failed to collect sample: %v\n", err)
                        continue</span>
                }

                // Display sample
                <span class="cov0" title="0">fmt.Printf("Sample %d (at %s):\n", i+1, sample.Timestamp.Format(time.RFC3339))
                if sample.CPUUtil != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  CPU Utilization: %.2f%%\n", *sample.CPUUtil)
                }</span>
                <span class="cov0" title="0">if sample.CPUWatts != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  CPU Power: %.2f W\n", *sample.CPUWatts)
                }</span>
                <span class="cov0" title="0">if sample.GPUUtil != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  GPU Utilization: %.2f%%\n", *sample.GPUUtil)
                }</span>
                <span class="cov0" title="0">if sample.GPUMemMB != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  GPU Memory: %d MB\n", *sample.GPUMemMB)
                }</span>
                <span class="cov0" title="0">if sample.GPUWatts != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  GPU Power: %.2f W\n", *sample.GPUWatts)
                }</span>
                <span class="cov0" title="0">if sample.TempGPU != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  GPU Temperature: %.1f¬∞C\n", *sample.TempGPU)
                }</span>
                <span class="cov0" title="0">if sample.EstTotalW != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  Estimated Total Power: %.2f W\n", *sample.EstTotalW)
                }</span>
                <span class="cov0" title="0">fmt.Println()

                // Write to temp file
                tmpFile := "/tmp/aistack_metrics_test.jsonl"
                if err := collector.WriteSample(sample, tmpFile); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: Failed to write sample: %v\n", err)
                }</span>

                // Wait before next sample (except for last one)
                <span class="cov0" title="0">if i &lt; 2 </span><span class="cov0" title="0">{
                        time.Sleep(5 * time.Second)
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("‚úì Metrics test completed")
        fmt.Println("Sample data written to: /tmp/aistack_metrics_test.jsonl")</span>
}

// printUsage displays usage information
func printUsage() <span class="cov0" title="0">{
        fmt.Printf(`aistack - AI Stack Management Tool (version %s)

Usage:
  aistack                          Start the interactive TUI (default)
  aistack agent                    Run as background agent service
  aistack idle-check               Perform idle evaluation (timer-triggered)
  aistack install --profile &lt;name&gt; Install services from profile (standard-gpu, minimal)
  aistack install &lt;service&gt;        Install a specific service (ollama, openwebui, localai)
  aistack start &lt;service&gt;          Start a service
  aistack stop &lt;service&gt;           Stop a service
  aistack status                   Show status of all services
  aistack gpu-check [--save]       Check GPU and NVIDIA stack availability
  aistack metrics-test             Test metrics collection (CPU/GPU)
  aistack version                  Print version information
  aistack help                     Show this help message

For more information, visit: https://github.com/polygonschmiede/aistack
`, version)
}</span>

func resolveComposeDir() string <span class="cov0" title="0">{
        if envDir := os.Getenv("AISTACK_COMPOSE_DIR"); envDir != "" </span><span class="cov0" title="0">{
                if abs, err := filepath.Abs(envDir); err == nil </span><span class="cov0" title="0">{
                        if dirExists(abs) </span><span class="cov0" title="0">{
                                return abs
                        }</span>
                }
        }

        <span class="cov0" title="0">if exePath, err := os.Executable(); err == nil </span><span class="cov0" title="0">{
                exeDir := filepath.Dir(exePath)
                candidates := []string{
                        filepath.Join(exeDir, "compose"),
                        filepath.Join(exeDir, "..", "share", "aistack", "compose"),
                }

                for _, candidate := range candidates </span><span class="cov0" title="0">{
                        if abs, err := filepath.Abs(candidate); err == nil &amp;&amp; dirExists(abs) </span><span class="cov0" title="0">{
                                return abs
                        }</span>
                }
        }

        <span class="cov0" title="0">if cwd, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                legacy := filepath.Join(cwd, "compose")
                if dirExists(legacy) </span><span class="cov0" title="0">{
                        return legacy
                }</span>
        }

        // Fallback to relative path; downstream code will surface a detailed error
        <span class="cov0" title="0">return "./compose"</span>
}

func dirExists(path string) bool <span class="cov0" title="0">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return info.IsDir()</span>
}

// parseFlags is a placeholder for future flag parsing
func parseFlags() <span class="cov0" title="0">{
        flag.Parse()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package agent provides the background service implementation for aistack
// This is a placeholder for EP-002 to satisfy systemd service requirements
package agent

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "path/filepath"
        "syscall"
        "time"

        "aistack/internal/idle"
        "aistack/internal/logging"
        "aistack/internal/metrics"
)

// Agent represents the background service
type Agent struct {
        logger               *logging.Logger
        ctx                  context.Context
        cancel               context.CancelFunc
        tickRate             time.Duration
        startTime            time.Time
        metricsCollector     *metrics.Collector
        idleEngine           *idle.Engine
        idleStateManager     *idle.StateManager
        idleExecutor         *idle.Executor
        metricsLogPath       string
        metricsWriteFailed   bool
        inhibitorCheckFailed bool
}

// NewAgent creates a new agent instance
func NewAgent(logger *logging.Logger) *Agent <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        // Initialize metrics collector
        metricsConfig := metrics.DefaultConfig()
        metricsCollector := metrics.NewCollector(metricsConfig, logger)

        // Initialize idle detection
        idleConfig := idle.DefaultIdleConfig()
        idleEngine := idle.NewEngine(idleConfig, logger)
        idleStateManager := idle.NewStateManager(idleConfig.StateFilePath, logger)
        idleExecutor := idle.NewExecutor(idleConfig, logger)

        metricsLogDir := resolveLogDir(logger)
        metricsLogPath := filepath.Join(metricsLogDir, "metrics.log")

        return &amp;Agent{
                logger:           logger,
                ctx:              ctx,
                cancel:           cancel,
                tickRate:         10 * time.Second, // Default tick rate
                startTime:        time.Now(),
                metricsCollector: metricsCollector,
                idleEngine:       idleEngine,
                idleStateManager: idleStateManager,
                idleExecutor:     idleExecutor,
                metricsLogPath:   metricsLogPath,
        }
}</span>

// Run starts the agent background service
func (a *Agent) Run() error <span class="cov0" title="0">{
        a.logger.Info("agent.started", "Agent service started", map[string]interface{}{
                "pid":       os.Getpid(),
                "tick_rate": a.tickRate.String(),
        })

        // Initialize metrics collector
        if err := a.metricsCollector.Initialize(); err != nil </span><span class="cov0" title="0">{
                a.logger.Warn("agent.metrics.init_failed", "Failed to initialize metrics collector", map[string]interface{}{
                        "error": err.Error(),
                })
        }</span>
        <span class="cov0" title="0">defer a.metricsCollector.Shutdown()

        // Setup signal handling for graceful shutdown
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM, syscall.SIGHUP)

        // Ticker for periodic tasks
        ticker := time.NewTicker(a.tickRate)
        defer ticker.Stop()

        // Main event loop
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-a.ctx.Done():<span class="cov0" title="0">
                        a.logger.Info("agent.context_cancelled", "Agent context cancelled", nil)
                        return a.ctx.Err()</span>

                case sig := &lt;-sigChan:<span class="cov0" title="0">
                        a.logger.Info("agent.signal_received", "Received signal", map[string]interface{}{
                                "signal": sig.String(),
                        })

                        switch sig </span>{
                        case syscall.SIGHUP:<span class="cov0" title="0">
                                // Reload configuration
                                a.logger.Info("agent.reload", "Reloading configuration", nil)</span>
                                // TODO: Implement config reload in future epic
                        case syscall.SIGTERM, syscall.SIGINT:<span class="cov0" title="0">
                                a.logger.Info("agent.shutdown", "Initiating graceful shutdown", nil)
                                return a.Shutdown()</span>
                        }

                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Periodic heartbeat and metrics collection
                        uptime := time.Since(a.startTime)
                        a.logger.Debug("agent.heartbeat", "Agent heartbeat", map[string]interface{}{
                                "uptime_seconds": uptime.Seconds(),
                        })

                        // Collect metrics and update idle engine
                        a.collectAndProcessMetrics()</span>
                }
        }
}

// collectAndProcessMetrics collects metrics and processes idle state
func (a *Agent) collectAndProcessMetrics() <span class="cov0" title="0">{
        // Collect metrics sample
        sample, err := a.metricsCollector.CollectSample()
        if err != nil </span><span class="cov0" title="0">{
                a.logger.Warn("agent.metrics.collect_failed", "Failed to collect metrics", map[string]interface{}{
                        "error": err.Error(),
                })
                return
        }</span>

        // Extract CPU and GPU utilization for idle detection
        <span class="cov0" title="0">cpuUtil := 0.0
        gpuUtil := 0.0

        if sample.CPUUtil != nil </span><span class="cov0" title="0">{
                cpuUtil = *sample.CPUUtil
        }</span>
        <span class="cov0" title="0">if sample.GPUUtil != nil </span><span class="cov0" title="0">{
                gpuUtil = *sample.GPUUtil
        }</span>

        // Add metrics to idle engine
        <span class="cov0" title="0">a.idleEngine.AddMetrics(cpuUtil, gpuUtil)

        // Get current idle state
        idleState := a.idleEngine.GetState()

        if a.idleExecutor != nil </span><span class="cov0" title="0">{
                if hasInhibit, inhibitors, err := a.idleExecutor.ActiveInhibitors(); err != nil </span><span class="cov0" title="0">{
                        if !a.inhibitorCheckFailed </span><span class="cov0" title="0">{
                                a.logger.Warn("agent.inhibitors.check_failed", "Failed to inspect systemd inhibitors", map[string]interface{}{
                                        "error": err.Error(),
                                })
                                a.inhibitorCheckFailed = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        if hasInhibit </span><span class="cov0" title="0">{
                                idleState.GatingReasons = addGatingReason(idleState.GatingReasons, idle.GatingReasonInhibit)
                                a.logger.Debug("agent.inhibitors.active", "Active inhibitors detected", map[string]interface{}{
                                        "count": len(inhibitors),
                                })
                        }</span> else<span class="cov0" title="0"> {
                                idleState.GatingReasons = removeGatingReason(idleState.GatingReasons, idle.GatingReasonInhibit)
                        }</span>
                        <span class="cov0" title="0">a.inhibitorCheckFailed = false</span>
                }
        }

        // Persist metrics sample to JSONL log
        <span class="cov0" title="0">if err := a.metricsCollector.WriteSample(sample, a.metricsLogPath); err != nil </span><span class="cov0" title="0">{
                if !a.metricsWriteFailed </span><span class="cov0" title="0">{
                        a.logger.Warn("agent.metrics.write_failed", "Failed to write metrics sample", map[string]interface{}{
                                "error": err.Error(),
                                "path":  a.metricsLogPath,
                        })
                        a.metricsWriteFailed = true
                }</span>
        } else<span class="cov0" title="0"> {
                if a.metricsWriteFailed </span><span class="cov0" title="0">{
                        a.logger.Info("agent.metrics.write_recovered", "Metrics logging restored", map[string]interface{}{
                                "path": a.metricsLogPath,
                        })
                }</span>
                <span class="cov0" title="0">a.metricsWriteFailed = false</span>
        }

        // Save idle state
        <span class="cov0" title="0">if err := a.idleStateManager.Save(idleState); err != nil </span><span class="cov0" title="0">{
                a.logger.Warn("agent.idle.state_save_failed", "Failed to save idle state", map[string]interface{}{
                        "error": err.Error(),
                })
        }</span>

        // Log idle state
        <span class="cov0" title="0">a.logger.Debug("agent.idle.state_updated", "Idle state updated", map[string]interface{}{
                "status":         idleState.Status,
                "idle_for_s":     idleState.IdleForSeconds,
                "threshold_s":    idleState.ThresholdSeconds,
                "gating_reasons": idleState.GatingReasons,
        })</span>
}

// resolveLogDir determines a writable log directory, favoring production defaults
func resolveLogDir(logger *logging.Logger) string <span class="cov0" title="0">{
        var candidates []string

        if envDir := os.Getenv("AISTACK_LOG_DIR"); envDir != "" </span><span class="cov0" title="0">{
                candidates = append(candidates, envDir)
        }</span>

        <span class="cov0" title="0">candidates = append(candidates, "/var/log/aistack")

        for _, dir := range candidates </span><span class="cov0" title="0">{
                if err := ensureWritableDir(dir); err == nil </span><span class="cov0" title="0">{
                        return dir
                }</span>

                <span class="cov0" title="0">logger.Warn("agent.logdir.unwritable", "Log directory not writable, trying fallback", map[string]interface{}{
                        "path": dir,
                })</span>
        }

        <span class="cov0" title="0">fallback := filepath.Join(os.TempDir(), "aistack")
        if err := ensureWritableDir(fallback); err != nil </span><span class="cov0" title="0">{
                logger.Error("agent.logdir.fallback_failed", "Failed to prepare fallback log directory", map[string]interface{}{
                        "path":  fallback,
                        "error": err.Error(),
                })
        }</span>
        <span class="cov0" title="0">return fallback</span>
}

func ensureWritableDir(path string) error <span class="cov0" title="0">{
        if err := os.MkdirAll(path, 0o755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">testFile := filepath.Join(path, ".write-test")
        if err := os.WriteFile(testFile, []byte{}, 0o644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.Remove(testFile)</span>
}

func addGatingReason(reasons []string, reason string) []string <span class="cov0" title="0">{
        for _, r := range reasons </span><span class="cov0" title="0">{
                if r == reason </span><span class="cov0" title="0">{
                        return reasons
                }</span>
        }
        <span class="cov0" title="0">return append(reasons, reason)</span>
}

func removeGatingReason(reasons []string, reason string) []string <span class="cov0" title="0">{
        filtered := make([]string, 0, len(reasons))
        for _, r := range reasons </span><span class="cov0" title="0">{
                if r != reason </span><span class="cov0" title="0">{
                        filtered = append(filtered, r)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// Shutdown performs graceful shutdown of the agent
func (a *Agent) Shutdown() error <span class="cov0" title="0">{
        a.logger.Info("agent.stopping", "Stopping agent service", nil)

        // Cancel context to stop all goroutines
        a.cancel()

        uptime := time.Since(a.startTime)
        a.logger.Info("agent.stopped", "Agent service stopped", map[string]interface{}{
                "uptime_seconds": uptime.Seconds(),
        })

        return nil
}</span>

// IdleCheck performs a single idle evaluation (for timer-triggered runs)
func IdleCheck(logger *logging.Logger) error <span class="cov0" title="0">{
        logger.Info("idle.check_started", "Idle check started", nil)

        // Load idle configuration
        idleConfig := idle.DefaultIdleConfig()

        // Create state manager and load current state
        stateManager := idle.NewStateManager(idleConfig.StateFilePath, logger)

        state, err := stateManager.Load()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("idle.state_load_failed", "Failed to load idle state", map[string]interface{}{
                        "error": err.Error(),
                })
                logger.Info("idle.check_completed", "Idle check completed (no state)", nil)
                return nil
        }</span>

        <span class="cov0" title="0">logger.Info("idle.state_loaded", "Idle state loaded", map[string]interface{}{
                "status":         state.Status,
                "idle_for_s":     state.IdleForSeconds,
                "threshold_s":    state.ThresholdSeconds,
                "gating_reasons": state.GatingReasons,
        })

        // Create idle engine and executor
        idleEngine := idle.NewEngine(idleConfig, logger)
        executor := idle.NewExecutor(idleConfig, logger)

        // Check if we should suspend
        if idleEngine.ShouldSuspend(state) </span><span class="cov0" title="0">{
                logger.Info("idle.suspend_check", "System should suspend", map[string]interface{}{
                        "idle_for_s":  state.IdleForSeconds,
                        "threshold_s": state.ThresholdSeconds,
                })

                // Attempt suspend
                if err := executor.Execute(&amp;state); err != nil </span><span class="cov0" title="0">{
                        logger.Error("idle.suspend_failed", "Failed to execute suspend", map[string]interface{}{
                                "error": err.Error(),
                        })
                        if saveErr := stateManager.Save(state); saveErr != nil </span><span class="cov0" title="0">{
                                logger.Warn("idle.state_save_failed", "Failed to persist updated state", map[string]interface{}{
                                        "error": saveErr.Error(),
                                })
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov0" title="0">if err := stateManager.Save(state); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("idle.state_save_failed", "Failed to persist updated state", map[string]interface{}{
                                "error": err.Error(),
                        })
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Info("idle.suspend_skipped", "Suspend not required", map[string]interface{}{
                        "status":         state.Status,
                        "idle_for_s":     state.IdleForSeconds,
                        "threshold_s":    state.ThresholdSeconds,
                        "gating_reasons": state.GatingReasons,
                })
        }</span>

        <span class="cov0" title="0">logger.Info("idle.check_completed", "Idle check completed", nil)
        return nil</span>
}

// HealthCheck performs a health check of the agent
func (a *Agent) HealthCheck() error <span class="cov0" title="0">{
        // Check if context is still valid
        select </span>{
        case &lt;-a.ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("agent context is cancelled")</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package gpu

import (
        "encoding/json"
        "fmt"
        "os"

        "aistack/internal/logging"
        "github.com/NVIDIA/go-nvml/pkg/nvml"
)

// Detector handles GPU detection and reporting
type Detector struct {
        nvml   NVMLInterface
        logger *logging.Logger
}

// NewDetector creates a new GPU detector
func NewDetector(logger *logging.Logger) *Detector <span class="cov8" title="1">{
        return &amp;Detector{
                nvml:   NewRealNVML(),
                logger: logger,
        }
}</span>

// NewDetectorWithNVML creates a detector with a custom NVML interface (for testing)
func NewDetectorWithNVML(nvmlInterface NVMLInterface, logger *logging.Logger) *Detector <span class="cov8" title="1">{
        return &amp;Detector{
                nvml:   nvmlInterface,
                logger: logger,
        }
}</span>

// DetectGPUs performs GPU detection and returns a report
// Story T-009: GPU-Erkennung &amp; NVML-Probe
func (d *Detector) DetectGPUs() GPUReport <span class="cov8" title="1">{
        d.logger.Info("gpu.detect.start", "Starting GPU detection", nil)

        report := GPUReport{
                GPUs: make([]GPUInfo, 0),
        }

        // Initialize NVML
        ret := d.nvml.Init()
        if ret != nvml.SUCCESS </span><span class="cov8" title="1">{
                report.NVMLOk = false
                report.ErrorMessage = fmt.Sprintf("Failed to initialize NVML: %v", nvml.ErrorString(ret))
                d.logger.Warn("gpu.nvml.init.failed", "NVML initialization failed", map[string]interface{}{
                        "error": report.ErrorMessage,
                })
                return report
        }</span>
        <span class="cov8" title="1">defer d.nvml.Shutdown()

        report.NVMLOk = true

        // Get driver version
        driverVersion, ret := d.nvml.SystemGetDriverVersion()
        if ret != nvml.SUCCESS </span><span class="cov0" title="0">{
                d.logger.Warn("gpu.driver.version.failed", "Failed to get driver version", map[string]interface{}{
                        "error": nvml.ErrorString(ret),
                })
        }</span> else<span class="cov8" title="1"> {
                report.DriverVersion = driverVersion
        }</span>

        // Get CUDA version
        <span class="cov8" title="1">cudaVersion, ret := d.nvml.SystemGetCudaDriverVersion()
        if ret != nvml.SUCCESS </span><span class="cov0" title="0">{
                d.logger.Warn("gpu.cuda.version.failed", "Failed to get CUDA version", map[string]interface{}{
                        "error": nvml.ErrorString(ret),
                })
        }</span> else<span class="cov8" title="1"> {
                report.CUDAVersion = cudaVersion
        }</span>

        // Get device count
        <span class="cov8" title="1">count, ret := d.nvml.DeviceGetCount()
        if ret != nvml.SUCCESS </span><span class="cov8" title="1">{
                report.ErrorMessage = fmt.Sprintf("Failed to get device count: %v", nvml.ErrorString(ret))
                d.logger.Error("gpu.device.count.failed", "Failed to get GPU count", map[string]interface{}{
                        "error": report.ErrorMessage,
                })
                return report
        }</span>

        <span class="cov8" title="1">d.logger.Info("gpu.device.count", "Found GPU devices", map[string]interface{}{
                "count": count,
        })

        // Iterate through devices
        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                device, ret := d.nvml.DeviceGetHandleByIndex(i)
                if ret != nvml.SUCCESS </span><span class="cov0" title="0">{
                        d.logger.Warn("gpu.device.handle.failed", "Failed to get device handle", map[string]interface{}{
                                "index": i,
                                "error": nvml.ErrorString(ret),
                        })
                        continue</span>
                }

                <span class="cov8" title="1">gpuInfo := GPUInfo{
                        Index: i,
                }

                // Get device name
                name, ret := device.GetName()
                if ret == nvml.SUCCESS </span><span class="cov8" title="1">{
                        gpuInfo.Name = name
                }</span>

                // Get device UUID
                <span class="cov8" title="1">uuid, ret := device.GetUUID()
                if ret == nvml.SUCCESS </span><span class="cov8" title="1">{
                        gpuInfo.UUID = uuid
                }</span>

                // Get memory info
                <span class="cov8" title="1">memInfo, ret := device.GetMemoryInfo()
                if ret == nvml.SUCCESS </span><span class="cov8" title="1">{
                        gpuInfo.MemoryMB = memInfo.Total / (1024 * 1024) // Convert bytes to MB
                }</span>

                <span class="cov8" title="1">report.GPUs = append(report.GPUs, gpuInfo)

                d.logger.Info("gpu.device.detected", "GPU device detected", map[string]interface{}{
                        "index":     i,
                        "name":      gpuInfo.Name,
                        "uuid":      gpuInfo.UUID,
                        "memory_mb": gpuInfo.MemoryMB,
                })</span>
        }

        <span class="cov8" title="1">return report</span>
}

// SaveReport saves the GPU report to a JSON file
func (d *Detector) SaveReport(report GPUReport, filepath string) error <span class="cov8" title="1">{
        data, err := json.MarshalIndent(report, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal report: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(filepath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write report file: %w", err)
        }</span>

        <span class="cov8" title="1">d.logger.Info("gpu.report.saved", "GPU report saved", map[string]interface{}{
                "filepath": filepath,
        })

        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package gpu

import (
        "github.com/NVIDIA/go-nvml/pkg/nvml"
)

// DeviceInterface defines the interface for GPU device operations (for mocking)
type DeviceInterface interface {
        GetName() (string, nvml.Return)
        GetUUID() (string, nvml.Return)
        GetMemoryInfo() (nvml.Memory, nvml.Return)
        GetUtilizationRates() (nvml.Utilization, nvml.Return)
        GetPowerUsage() (uint32, nvml.Return)
        GetTemperature(sensor nvml.TemperatureSensors) (uint32, nvml.Return)
}

// NVMLInterface defines the interface for NVML operations (for mocking)
type NVMLInterface interface {
        Init() nvml.Return
        Shutdown() nvml.Return
        DeviceGetCount() (int, nvml.Return)
        DeviceGetHandleByIndex(index int) (DeviceInterface, nvml.Return)
        SystemGetDriverVersion() (string, nvml.Return)
        SystemGetCudaDriverVersion() (int, nvml.Return)
}

// deviceWrapper wraps nvml.Device to implement DeviceInterface
type deviceWrapper struct {
        device nvml.Device
}

func (w deviceWrapper) GetName() (string, nvml.Return) <span class="cov0" title="0">{
        return w.device.GetName()
}</span>

func (w deviceWrapper) GetUUID() (string, nvml.Return) <span class="cov0" title="0">{
        return w.device.GetUUID()
}</span>

func (w deviceWrapper) GetMemoryInfo() (nvml.Memory, nvml.Return) <span class="cov0" title="0">{
        return w.device.GetMemoryInfo()
}</span>

func (w deviceWrapper) GetUtilizationRates() (nvml.Utilization, nvml.Return) <span class="cov0" title="0">{
        return w.device.GetUtilizationRates()
}</span>

func (w deviceWrapper) GetPowerUsage() (uint32, nvml.Return) <span class="cov0" title="0">{
        return w.device.GetPowerUsage()
}</span>

func (w deviceWrapper) GetTemperature(sensor nvml.TemperatureSensors) (uint32, nvml.Return) <span class="cov0" title="0">{
        return w.device.GetTemperature(sensor)
}</span>

// RealNVML implements NVMLInterface using actual NVML library
type RealNVML struct{}

// NewRealNVML creates a new real NVML instance
func NewRealNVML() *RealNVML <span class="cov8" title="1">{
        return &amp;RealNVML{}
}</span>

// Init initializes NVML
func (r *RealNVML) Init() nvml.Return <span class="cov0" title="0">{
        return nvml.Init()
}</span>

// Shutdown shuts down NVML
func (r *RealNVML) Shutdown() nvml.Return <span class="cov0" title="0">{
        return nvml.Shutdown()
}</span>

// DeviceGetCount returns the number of GPU devices
func (r *RealNVML) DeviceGetCount() (int, nvml.Return) <span class="cov0" title="0">{
        return nvml.DeviceGetCount()
}</span>

// DeviceGetHandleByIndex returns a handle to a GPU device
func (r *RealNVML) DeviceGetHandleByIndex(index int) (DeviceInterface, nvml.Return) <span class="cov0" title="0">{
        device, ret := nvml.DeviceGetHandleByIndex(index)
        if ret != nvml.SUCCESS </span><span class="cov0" title="0">{
                return nil, ret
        }</span>
        <span class="cov0" title="0">return deviceWrapper{device: device}, ret</span>
}

// SystemGetDriverVersion returns the driver version
func (r *RealNVML) SystemGetDriverVersion() (string, nvml.Return) <span class="cov0" title="0">{
        return nvml.SystemGetDriverVersion()
}</span>

// SystemGetCudaDriverVersion returns the CUDA driver version
func (r *RealNVML) SystemGetCudaDriverVersion() (int, nvml.Return) <span class="cov0" title="0">{
        return nvml.SystemGetCudaDriverVersion()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package gpu

import (
        "bytes"
        "encoding/json"
        "fmt"
        "os/exec"
        "strings"

        "aistack/internal/logging"
)

// ToolkitDetector handles NVIDIA Container Toolkit detection
// Story T-010: NVIDIA Container Toolkit Detection
type ToolkitDetector struct {
        logger *logging.Logger
}

// NewToolkitDetector creates a new toolkit detector
func NewToolkitDetector(logger *logging.Logger) *ToolkitDetector <span class="cov8" title="1">{
        return &amp;ToolkitDetector{
                logger: logger,
        }
}</span>

// DetectContainerToolkit checks if NVIDIA Container Toolkit is available
// Story T-010: Test-Container mit --gpus all dry-run
func (td *ToolkitDetector) DetectContainerToolkit() ContainerToolkitReport <span class="cov8" title="1">{
        td.logger.Info("gpu.toolkit.detect.start", "Starting Container Toolkit detection", nil)

        report := ContainerToolkitReport{
                DockerSupport: false,
        }

        // First, check if docker is available
        if !td.isDockerAvailable() </span><span class="cov8" title="1">{
                report.ErrorMessage = "Docker is not available"
                td.logger.Warn("gpu.toolkit.docker.unavailable", "Docker not found", nil)
                return report
        }</span>

        <span class="cov0" title="0">support, detail, err := td.detectDockerRuntime()
        if err != nil </span><span class="cov0" title="0">{
                report.ErrorMessage = detail
                td.logger.Warn("gpu.toolkit.inspect.failed", "Failed to inspect docker runtime", map[string]interface{}{
                        "error": err.Error(),
                })
                return report
        }</span>

        <span class="cov0" title="0">if !support </span><span class="cov0" title="0">{
                report.ErrorMessage = detail
                td.logger.Info("gpu.toolkit.runtime.absent", "NVIDIA runtime not detected", map[string]interface{}{
                        "detail": detail,
                })
                return report
        }</span>

        <span class="cov0" title="0">report.DockerSupport = true

        // Try to extract toolkit version from nvidia-container-toolkit
        version := td.getToolkitVersion()
        if version != "" </span><span class="cov0" title="0">{
                report.ToolkitVersion = version
        }</span>

        <span class="cov0" title="0">td.logger.Info("gpu.toolkit.detected", "Container Toolkit detected successfully", map[string]interface{}{
                "version": report.ToolkitVersion,
        })

        return report</span>
}

// isDockerAvailable checks if Docker daemon is running
func (td *ToolkitDetector) isDockerAvailable() bool <span class="cov8" title="1">{
        cmd := exec.Command("docker", "info")
        return cmd.Run() == nil
}</span>

func (td *ToolkitDetector) detectDockerRuntime() (bool, string, error) <span class="cov0" title="0">{
        var stdout, stderr bytes.Buffer
        cmd := exec.Command("docker", "info", "--format", "{{json .Runtimes}}")
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err == nil </span><span class="cov0" title="0">{
                runtimes := make(map[string]json.RawMessage)
                if err := json.Unmarshal(stdout.Bytes(), &amp;runtimes); err == nil </span><span class="cov0" title="0">{
                        if _, ok := runtimes["nvidia"]; ok </span><span class="cov0" title="0">{
                                return true, "", nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        td.logger.Warn("gpu.toolkit.runtime.parse_failed", "Failed to parse docker runtime json", map[string]interface{}{
                                "error": err.Error(),
                        })
                }</span>
        }

        <span class="cov0" title="0">stdout.Reset()
        stderr.Reset()
        cmd = exec.Command("docker", "info")
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("docker info failed: %v", err), err
        }</span>

        <span class="cov0" title="0">infoOutput := stdout.String()
        if strings.Contains(infoOutput, "Runtimes: nvidia") || strings.Contains(infoOutput, "nvidia-container-runtime") </span><span class="cov0" title="0">{
                return true, "", nil
        }</span>

        <span class="cov0" title="0">return false, "NVIDIA runtime not listed in docker info", nil</span>
}

// getToolkitVersion attempts to get the NVIDIA Container Toolkit version
func (td *ToolkitDetector) getToolkitVersion() string <span class="cov0" title="0">{
        cmd := exec.Command("nvidia-container-toolkit", "--version")
        var stdout bytes.Buffer
        cmd.Stdout = &amp;stdout

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                // Toolkit CLI might not be in PATH, this is optional
                return ""
        }</span>

        // Parse version from output
        <span class="cov0" title="0">output := stdout.String()
        // Expected format: "NVIDIA Container Toolkit version X.Y.Z"
        lines := strings.Split(output, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, "version") </span><span class="cov0" title="0">{
                        parts := strings.Fields(line)
                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                return parts[len(parts)-1]
                        }</span>
                }
        }

        <span class="cov0" title="0">return ""</span>
}

// QuickGPUCheck performs a quick GPU availability check without full detection
// This is useful for fast pre-flight checks
func (td *ToolkitDetector) QuickGPUCheck() bool <span class="cov8" title="1">{
        cmd := exec.Command("nvidia-smi")
        return cmd.Run() == nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package idle

import (
        "time"

        "aistack/internal/logging"
)

// Engine is the idle detection engine
type Engine struct {
        config IdleConfig
        window *SlidingWindow
        logger *logging.Logger
}

// NewEngine creates a new idle detection engine
func NewEngine(config IdleConfig, logger *logging.Logger) *Engine <span class="cov8" title="1">{
        return &amp;Engine{
                config: config,
                window: NewSlidingWindow(config.WindowSeconds, config.MinSamplesRequired),
                logger: logger,
        }
}</span>

// AddMetrics adds new CPU/GPU metrics to the idle detection engine
func (e *Engine) AddMetrics(cpuUtil, gpuUtil float64) <span class="cov8" title="1">{
        sample := MetricSample{
                Timestamp: time.Now(),
                CPUUtil:   cpuUtil,
                GPUUtil:   gpuUtil,
        }

        e.window.AddSample(sample)

        e.logger.Debug("idle.metrics.added", "Added metrics sample", map[string]interface{}{
                "cpu_util": cpuUtil,
                "gpu_util": gpuUtil,
                "samples":  e.window.SampleCount(),
        })
}</span>

// GetState calculates and returns the current idle state
func (e *Engine) GetState() IdleState <span class="cov8" title="1">{
        // Check if we have enough samples
        if !e.window.HasEnoughSamples() </span><span class="cov8" title="1">{
                return IdleState{
                        Status:           StatusWarmingUp,
                        IdleForSeconds:   0,
                        ThresholdSeconds: e.config.IdleTimeoutSeconds,
                        CPUIdlePct:       0,
                        GPUIdlePct:       0,
                        GatingReasons:    []string{GatingReasonWarmingUp},
                        LastUpdate:       time.Now(),
                }
        }</span>

        // Check if idle
        <span class="cov8" title="1">idle, cpuAvg, gpuAvg := e.window.IsIdle(e.config.CPUThresholdPct, e.config.GPUThresholdPct)
        idleDuration := e.window.GetIdleDuration(e.config.CPUThresholdPct, e.config.GPUThresholdPct)

        // Calculate CPU/GPU idle percentages (inverse of utilization)
        cpuIdlePct := 100.0 - cpuAvg
        gpuIdlePct := 100.0 - gpuAvg

        // Determine status and gating reasons
        var status string
        gatingReasons := make([]string, 0)

        if !idle </span><span class="cov8" title="1">{
                status = StatusActive

                // Determine why we're not idle
                if cpuAvg &gt;= e.config.CPUThresholdPct </span><span class="cov8" title="1">{
                        gatingReasons = append(gatingReasons, GatingReasonHighCPU)
                }</span>
                <span class="cov8" title="1">if gpuAvg &gt;= e.config.GPUThresholdPct </span><span class="cov8" title="1">{
                        gatingReasons = append(gatingReasons, GatingReasonHighGPU)
                }</span>
        } else<span class="cov8" title="1"> {
                // System is idle, but check if we've been idle long enough
                idleSeconds := int(idleDuration.Seconds())
                if idleSeconds &lt; e.config.IdleTimeoutSeconds </span><span class="cov8" title="1">{
                        status = StatusIdle
                        gatingReasons = append(gatingReasons, GatingReasonBelowTimeout)
                }</span> else<span class="cov0" title="0"> {
                        status = StatusIdle
                        // No gating reasons - ready for suspend
                }</span>
        }

        <span class="cov8" title="1">state := IdleState{
                Status:           status,
                IdleForSeconds:   int(idleDuration.Seconds()),
                ThresholdSeconds: e.config.IdleTimeoutSeconds,
                CPUIdlePct:       cpuIdlePct,
                GPUIdlePct:       gpuIdlePct,
                GatingReasons:    gatingReasons,
                LastUpdate:       time.Now(),
        }

        e.logger.Debug("idle.state.calculated", "Calculated idle state", map[string]interface{}{
                "status":         state.Status,
                "idle_for_s":     state.IdleForSeconds,
                "cpu_idle_pct":   state.CPUIdlePct,
                "gpu_idle_pct":   state.GPUIdlePct,
                "gating_reasons": state.GatingReasons,
        })

        return state</span>
}

// ShouldSuspend checks if the system should suspend based on current state
func (e *Engine) ShouldSuspend(state IdleState) bool <span class="cov8" title="1">{
        // Don't suspend if warming up
        if state.Status == StatusWarmingUp </span><span class="cov8" title="1">{
                return false
        }</span>

        // Don't suspend if not idle
        <span class="cov8" title="1">if state.Status != StatusIdle </span><span class="cov8" title="1">{
                return false
        }</span>

        // Don't suspend if there are gating reasons
        <span class="cov8" title="1">if len(state.GatingReasons) &gt; 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if idle duration meets threshold
        <span class="cov8" title="1">return state.IdleForSeconds &gt;= e.config.IdleTimeoutSeconds</span>
}

// Reset resets the idle detection engine
func (e *Engine) Reset() <span class="cov8" title="1">{
        e.window.Reset()
        e.logger.Info("idle.engine.reset", "Idle engine reset", nil)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package idle

import (
        "fmt"
        "os/exec"
        "strings"

        "aistack/internal/logging"
)

// Executor handles suspend execution with inhibit checking
type Executor struct {
        config IdleConfig
        logger *logging.Logger
}

// NewExecutor creates a new suspend executor
func NewExecutor(config IdleConfig, logger *logging.Logger) *Executor <span class="cov8" title="1">{
        return &amp;Executor{
                config: config,
                logger: logger,
        }
}</span>

// Execute attempts to execute suspend with appropriate gate checks
func (e *Executor) Execute(state *IdleState) error <span class="cov8" title="1">{
        // Check if any other gating reasons exist first (before checking inhibitors)
        if len(state.GatingReasons) &gt; 0 </span><span class="cov8" title="1">{
                e.logger.Info("power.suspend.skipped", "Suspend skipped due to gating reasons", map[string]interface{}{
                        "idle_for_s":     state.IdleForSeconds,
                        "gating_reasons": state.GatingReasons,
                })
                return fmt.Errorf("suspend blocked by gating reasons: %s", strings.Join(state.GatingReasons, ", "))
        }</span>

        // Check if suspend is enabled
        <span class="cov8" title="1">if !e.config.EnableSuspend </span><span class="cov8" title="1">{
                e.logger.Info("power.suspend.skipped", "Suspend skipped (dry-run mode)", map[string]interface{}{
                        "idle_for_s": state.IdleForSeconds,
                        "reason":     "dry_run",
                })
                return nil
        }</span>

        // Check for inhibitors
        <span class="cov0" title="0">hasInhibit, inhibitors, err := e.checkInhibitors()
        if err != nil </span><span class="cov0" title="0">{
                e.logger.Warn("power.inhibit.check.failed", "Failed to check inhibitors", map[string]interface{}{
                        "error": err.Error(),
                })
                // Continue anyway - don't block on check failure
        }</span>

        <span class="cov0" title="0">if hasInhibit </span><span class="cov0" title="0">{
                e.logger.Info("power.suspend.skipped", "Suspend skipped due to inhibitors", map[string]interface{}{
                        "idle_for_s": state.IdleForSeconds,
                        "reason":     GatingReasonInhibit,
                        "inhibitors": inhibitors,
                })

                // Add inhibit to gating reasons
                if state.GatingReasons == nil </span><span class="cov0" title="0">{
                        state.GatingReasons = make([]string, 0)
                }</span>
                <span class="cov0" title="0">if !containsReason(state.GatingReasons, GatingReasonInhibit) </span><span class="cov0" title="0">{
                        state.GatingReasons = append(state.GatingReasons, GatingReasonInhibit)
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("suspend blocked by inhibitors: %s", strings.Join(inhibitors, ", "))</span>
        }

        // All gates passed - request suspend
        <span class="cov0" title="0">e.logger.Info("power.suspend.requested", "Suspend requested", map[string]interface{}{
                "idle_for_s":    state.IdleForSeconds,
                "threshold_s":   state.ThresholdSeconds,
                "cpu_idle_pct":  state.CPUIdlePct,
                "gpu_idle_pct":  state.GPUIdlePct,
                "enable_actual": e.config.EnableSuspend,
        })

        // Execute systemctl suspend
        if err := e.executeSuspend(); err != nil </span><span class="cov0" title="0">{
                e.logger.Error("power.suspend.failed", "Failed to execute suspend", map[string]interface{}{
                        "error": err.Error(),
                })
                return fmt.Errorf("failed to execute suspend: %w", err)
        }</span>

        <span class="cov0" title="0">e.logger.Info("power.suspend.done", "Suspend executed successfully", nil)
        return nil</span>
}

// ActiveInhibitors returns whether there are active systemd inhibitors blocking suspend
func (e *Executor) ActiveInhibitors() (bool, []string, error) <span class="cov0" title="0">{
        return e.checkInhibitors()
}</span>

// checkInhibitors checks for active systemd inhibitors
func (e *Executor) checkInhibitors() (bool, []string, error) <span class="cov0" title="0">{
        // Run systemd-inhibit --list to check for active inhibitors
        cmd := exec.Command("systemd-inhibit", "--list", "--no-pager", "--no-legend")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                // If command doesn't exist or fails, assume no inhibitors
                return false, nil, err
        }</span>

        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(string(output)), "\n")
        inhibitors := make([]string, 0)

        // Parse output for sleep/shutdown inhibitors
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.Contains(line, "sleep") || strings.Contains(line, "shutdown") </span><span class="cov0" title="0">{
                        fields := strings.Fields(line)
                        if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                                inhibitors = append(inhibitors, fields[0]) // Add the inhibitor name
                        }</span>
                }
        }

        <span class="cov0" title="0">hasInhibit := len(inhibitors) &gt; 0

        e.logger.Debug("power.inhibit.checked", "Checked for inhibitors", map[string]interface{}{
                "has_inhibit": hasInhibit,
                "inhibitors":  inhibitors,
        })

        return hasInhibit, inhibitors, nil</span>
}

// executeSuspend executes the actual suspend command
func (e *Executor) executeSuspend() error <span class="cov0" title="0">{
        cmd := exec.Command("systemctl", "suspend")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("systemctl suspend failed: %w (output: %s)", err, string(output))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CheckCanSuspend performs a dry-run check to see if suspend is possible
func (e *Executor) CheckCanSuspend() error <span class="cov0" title="0">{
        // Check if systemctl is available
        if _, err := exec.LookPath("systemctl"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("systemctl not found: %w", err)
        }</span>

        // Check if suspend is supported (this won't actually suspend)
        <span class="cov0" title="0">cmd := exec.Command("systemctl", "can-suspend")
        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("suspend not supported by system: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func containsReason(reasons []string, target string) bool <span class="cov0" title="0">{
        for _, r := range reasons </span><span class="cov0" title="0">{
                if r == target </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package idle

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "aistack/internal/logging"
)

// StateManager handles idle state persistence
type StateManager struct {
        filePath string
        logger   *logging.Logger
}

// NewStateManager creates a new state manager
func NewStateManager(filePath string, logger *logging.Logger) *StateManager <span class="cov8" title="1">{
        return &amp;StateManager{
                filePath: filePath,
                logger:   logger,
        }
}</span>

// Save writes the idle state to the configured file
func (sm *StateManager) Save(state IdleState) error <span class="cov8" title="1">{
        // Ensure directory exists
        dir := filepath.Dir(sm.filePath)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Marshal to JSON
        <span class="cov8" title="1">data, err := json.MarshalIndent(state, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal state: %w", err)
        }</span>

        // Write to file atomically (write to temp, then rename)
        <span class="cov8" title="1">tempPath := sm.filePath + ".tmp"
        if err := os.WriteFile(tempPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write temp file: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.Rename(tempPath, sm.filePath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to rename temp file: %w", err)
        }</span>

        <span class="cov8" title="1">sm.logger.Debug("idle.state.saved", "Idle state saved", map[string]interface{}{
                "path":   sm.filePath,
                "status": state.Status,
        })

        return nil</span>
}

// Load reads the idle state from the configured file
func (sm *StateManager) Load() (IdleState, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(sm.filePath)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return IdleState{}, fmt.Errorf("state file not found: %w", err)
                }</span>
                <span class="cov0" title="0">return IdleState{}, fmt.Errorf("failed to read state file: %w", err)</span>
        }

        <span class="cov8" title="1">var state IdleState
        if err := json.Unmarshal(data, &amp;state); err != nil </span><span class="cov0" title="0">{
                return IdleState{}, fmt.Errorf("failed to unmarshal state: %w", err)
        }</span>

        <span class="cov8" title="1">sm.logger.Debug("idle.state.loaded", "Idle state loaded", map[string]interface{}{
                "path":   sm.filePath,
                "status": state.Status,
        })

        return state, nil</span>
}

// Delete removes the state file
func (sm *StateManager) Delete() error <span class="cov8" title="1">{
        if err := os.Remove(sm.filePath); err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil // Already deleted
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to delete state file: %w", err)</span>
        }

        <span class="cov8" title="1">sm.logger.Debug("idle.state.deleted", "Idle state file deleted", map[string]interface{}{
                "path": sm.filePath,
        })

        return nil</span>
}

// Exists checks if the state file exists
func (sm *StateManager) Exists() bool <span class="cov8" title="1">{
        _, err := os.Stat(sm.filePath)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package idle

import (
        "os"
        "path/filepath"
        "time"
)

// IdleConfig holds configuration for idle detection and suspend behavior
type IdleConfig struct {
        // WindowSeconds is the size of the sliding window for idle calculation
        WindowSeconds int `json:"window_seconds"`

        // IdleTimeoutSeconds is the duration of idle time before triggering suspend
        IdleTimeoutSeconds int `json:"idle_timeout_seconds"`

        // CPUThresholdPct is the CPU utilization threshold (%) below which CPU is considered idle
        CPUThresholdPct float64 `json:"cpu_threshold_pct"`

        // GPUThresholdPct is the GPU utilization threshold (%) below which GPU is considered idle
        GPUThresholdPct float64 `json:"gpu_threshold_pct"`

        // MinSamplesRequired is the minimum number of samples before calculating idle state
        MinSamplesRequired int `json:"min_samples_required"`

        // EnableSuspend enables actual suspend execution (false for dry-run)
        EnableSuspend bool `json:"enable_suspend"`

        // StateFilePath is the path to the idle state JSON file
        StateFilePath string `json:"state_file_path"`
}

// DefaultIdleConfig returns default idle configuration
func DefaultIdleConfig() IdleConfig <span class="cov8" title="1">{
        stateDir := "/var/lib/aistack"

        if envDir := os.Getenv("AISTACK_STATE_DIR"); envDir != "" </span><span class="cov0" title="0">{
                stateDir = envDir
        }</span> else<span class="cov8" title="1"> if os.Geteuid() != 0 </span><span class="cov8" title="1">{
                if home, err := os.UserHomeDir(); err == nil </span><span class="cov8" title="1">{
                        stateDir = filepath.Join(home, ".local", "state", "aistack")
                }</span> else<span class="cov0" title="0"> {
                        stateDir = filepath.Join(os.TempDir(), "aistack")
                }</span>
        }

        <span class="cov8" title="1">return IdleConfig{
                WindowSeconds:      60,  // 60 second sliding window
                IdleTimeoutSeconds: 300, // 5 minutes idle timeout
                CPUThresholdPct:    10.0,
                GPUThresholdPct:    5.0,
                MinSamplesRequired: 6, // At least 6 samples (60s / 10s sample interval)
                EnableSuspend:      true,
                StateFilePath:      filepath.Join(stateDir, "idle_state.json"),
        }</span>
}

// IdleState represents the current idle state of the system
type IdleState struct {
        // Status is the current idle status (warming_up, active, idle)
        Status string `json:"status"`

        // IdleForSeconds is how long the system has been continuously idle
        IdleForSeconds int `json:"idle_for_s"`

        // ThresholdSeconds is the configured idle timeout threshold
        ThresholdSeconds int `json:"threshold_s"`

        // CPUIdlePct is the current CPU idle percentage
        CPUIdlePct float64 `json:"cpu_idle_pct"`

        // GPUIdlePct is the current GPU idle percentage
        GPUIdlePct float64 `json:"gpu_idle_pct"`

        // GatingReasons lists reasons preventing suspend
        GatingReasons []string `json:"gating_reasons"`

        // LastUpdate is the timestamp of the last state update
        LastUpdate time.Time `json:"last_update"`
}

// Idle status constants
const (
        StatusWarmingUp = "warming_up"
        StatusActive    = "active"
        StatusIdle      = "idle"
)

// MetricSample represents a single metric sample for idle calculation
type MetricSample struct {
        Timestamp time.Time
        CPUUtil   float64
        GPUUtil   float64
}

// GatingReason represents reasons that prevent suspend
const (
        GatingReasonInhibit      = "inhibit"
        GatingReasonBelowTimeout = "below_timeout"
        GatingReasonHighCPU      = "high_cpu"
        GatingReasonHighGPU      = "high_gpu"
        GatingReasonWarmingUp    = "warming_up"
)
</pre>
		
		<pre class="file" id="file9" style="display: none">package idle

import (
        "sync"
        "time"
)

// SlidingWindow maintains a time-based sliding window of metric samples
type SlidingWindow struct {
        mu           sync.RWMutex
        samples      []MetricSample
        windowSize   time.Duration
        minSamples   int
        lastIdleTime time.Time
        idleDuration time.Duration
}

// NewSlidingWindow creates a new sliding window
func NewSlidingWindow(windowSeconds int, minSamples int) *SlidingWindow <span class="cov8" title="1">{
        return &amp;SlidingWindow{
                samples:      make([]MetricSample, 0),
                windowSize:   time.Duration(windowSeconds) * time.Second,
                minSamples:   minSamples,
                lastIdleTime: time.Time{},
                idleDuration: 0,
        }
}</span>

// AddSample adds a new metric sample to the window
func (w *SlidingWindow) AddSample(sample MetricSample) <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        // Add new sample
        w.samples = append(w.samples, sample)

        // Remove samples outside the window
        cutoff := time.Now().Add(-w.windowSize)
        validSamples := make([]MetricSample, 0)
        for _, s := range w.samples </span><span class="cov8" title="1">{
                if s.Timestamp.After(cutoff) </span><span class="cov8" title="1">{
                        validSamples = append(validSamples, s)
                }</span>
        }
        <span class="cov8" title="1">w.samples = validSamples</span>
}

// IsIdle checks if the system is currently idle based on thresholds
func (w *SlidingWindow) IsIdle(cpuThreshold, gpuThreshold float64) (bool, float64, float64) <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        if len(w.samples) &lt; w.minSamples </span><span class="cov0" title="0">{
                return false, 0, 0
        }</span>

        // Calculate average utilization over the window
        <span class="cov8" title="1">var cpuSum, gpuSum float64
        for _, s := range w.samples </span><span class="cov8" title="1">{
                cpuSum += s.CPUUtil
                gpuSum += s.GPUUtil
        }</span>

        <span class="cov8" title="1">cpuAvg := cpuSum / float64(len(w.samples))
        gpuAvg := gpuSum / float64(len(w.samples))

        // System is idle if both CPU and GPU are below their thresholds
        idle := cpuAvg &lt; cpuThreshold &amp;&amp; gpuAvg &lt; gpuThreshold

        return idle, cpuAvg, gpuAvg</span>
}

// HasEnoughSamples checks if we have enough samples to make a decision
func (w *SlidingWindow) HasEnoughSamples() bool <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()
        return len(w.samples) &gt;= w.minSamples
}</span>

// GetIdleDuration returns how long the system has been continuously idle
func (w *SlidingWindow) GetIdleDuration(cpuThreshold, gpuThreshold float64) time.Duration <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        idle, _, _ := w.isIdleLocked(cpuThreshold, gpuThreshold)

        now := time.Now()
        if idle </span><span class="cov8" title="1">{
                // System is currently idle
                if w.lastIdleTime.IsZero() </span><span class="cov8" title="1">{
                        // Just became idle
                        w.lastIdleTime = now
                        w.idleDuration = 0
                }</span> else<span class="cov8" title="1"> {
                        // Continue being idle
                        w.idleDuration = now.Sub(w.lastIdleTime)
                }</span>
        } else<span class="cov8" title="1"> {
                // System is active - reset idle tracking
                w.lastIdleTime = time.Time{}
                w.idleDuration = 0
        }</span>

        <span class="cov8" title="1">return w.idleDuration</span>
}

// isIdleLocked is the internal idle check without locking (caller must hold lock)
func (w *SlidingWindow) isIdleLocked(cpuThreshold, gpuThreshold float64) (bool, float64, float64) <span class="cov8" title="1">{
        if len(w.samples) &lt; w.minSamples </span><span class="cov8" title="1">{
                return false, 0, 0
        }</span>

        <span class="cov8" title="1">var cpuSum, gpuSum float64
        for _, s := range w.samples </span><span class="cov8" title="1">{
                cpuSum += s.CPUUtil
                gpuSum += s.GPUUtil
        }</span>

        <span class="cov8" title="1">cpuAvg := cpuSum / float64(len(w.samples))
        gpuAvg := gpuSum / float64(len(w.samples))

        idle := cpuAvg &lt; cpuThreshold &amp;&amp; gpuAvg &lt; gpuThreshold

        return idle, cpuAvg, gpuAvg</span>
}

// Reset clears all samples and resets idle tracking
func (w *SlidingWindow) Reset() <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        w.samples = make([]MetricSample, 0)
        w.lastIdleTime = time.Time{}
        w.idleDuration = 0
}</span>

// SampleCount returns the current number of samples in the window
func (w *SlidingWindow) SampleCount() int <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()
        return len(w.samples)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package logging

import (
        "encoding/json"
        "fmt"
        "os"
        "time"
)

// Level represents log severity
type Level string

const (
        LevelDebug Level = "debug"
        LevelInfo  Level = "info"
        LevelWarn  Level = "warn"
        LevelError Level = "error"
)

// Event represents a structured log event
type Event struct {
        Timestamp string                 `json:"ts"`
        Level     Level                  `json:"level"`
        Type      string                 `json:"type"`
        Message   string                 `json:"message"`
        Payload   map[string]interface{} `json:"payload,omitempty"`
}

// Logger provides structured logging
type Logger struct {
        minLevel Level
}

// NewLogger creates a new logger
func NewLogger(minLevel Level) *Logger <span class="cov8" title="1">{
        return &amp;Logger{minLevel: minLevel}
}</span>

// Log writes a structured log event
func (l *Logger) Log(level Level, eventType, message string, payload map[string]interface{}) <span class="cov8" title="1">{
        if !l.shouldLog(level) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">event := Event{
                Timestamp: time.Now().UTC().Format(time.RFC3339),
                Level:     level,
                Type:      eventType,
                Message:   message,
                Payload:   payload,
        }

        data, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to marshal log event: %v\n", err)
                return
        }</span>

        <span class="cov8" title="1">fmt.Fprintln(os.Stderr, string(data))</span>
}

// Debug logs a debug-level event
func (l *Logger) Debug(eventType, message string, payload map[string]interface{}) <span class="cov0" title="0">{
        l.Log(LevelDebug, eventType, message, payload)
}</span>

// Info logs an info-level event
func (l *Logger) Info(eventType, message string, payload map[string]interface{}) <span class="cov8" title="1">{
        l.Log(LevelInfo, eventType, message, payload)
}</span>

// Warn logs a warn-level event
func (l *Logger) Warn(eventType, message string, payload map[string]interface{}) <span class="cov0" title="0">{
        l.Log(LevelWarn, eventType, message, payload)
}</span>

// Error logs an error-level event
func (l *Logger) Error(eventType, message string, payload map[string]interface{}) <span class="cov8" title="1">{
        l.Log(LevelError, eventType, message, payload)
}</span>

// shouldLog determines if a log level should be output
func (l *Logger) shouldLog(level Level) bool <span class="cov8" title="1">{
        levels := map[Level]int{
                LevelDebug: 0,
                LevelInfo:  1,
                LevelWarn:  2,
                LevelError: 3,
        }
        return levels[level] &gt;= levels[l.minLevel]
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package metrics

import (
        "time"

        "aistack/internal/logging"
)

// Collector aggregates metrics from CPU and GPU collectors
type Collector struct {
        logger       *logging.Logger
        config       MetricsConfig
        cpuCollector *CPUCollector
        gpuCollector *GPUCollector
        writer       *Writer
}

// NewCollector creates a new metrics collector
func NewCollector(config MetricsConfig, logger *logging.Logger) *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                logger:       logger,
                config:       config,
                cpuCollector: NewCPUCollector(logger, config.EnableCPUPower),
                writer:       NewWriter(logger),
        }
}</span>

// Initialize initializes the metrics collector
func (c *Collector) Initialize() error <span class="cov0" title="0">{
        c.logger.Info("metrics.collector.init", "Initializing metrics collector", map[string]interface{}{
                "sample_interval": c.config.SampleInterval.String(),
                "enable_gpu":      c.config.EnableGPU,
        })

        // Initialize GPU collector if enabled
        if c.config.EnableGPU </span><span class="cov0" title="0">{
                c.gpuCollector = NewGPUCollector(c.logger)
                if err := c.gpuCollector.Initialize(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("metrics.gpu.init.failed", "GPU metrics disabled", map[string]interface{}{
                                "error": err.Error(),
                        })
                        c.config.EnableGPU = false // Disable if init fails
                }</span>
        }

        // Disable CPU power metrics if requested or unavailable
        <span class="cov0" title="0">if !c.config.EnableCPUPower &amp;&amp; c.cpuCollector != nil </span><span class="cov0" title="0">{
                c.cpuCollector.EnablePowerMetrics(false)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CollectSample collects a single metrics sample
func (c *Collector) CollectSample() (MetricsSample, error) <span class="cov0" title="0">{
        sample := MetricsSample{
                Timestamp: time.Now().UTC(),
        }

        // Collect CPU metrics
        cpuUtil, cpuWatts, tempCPU, err := c.cpuCollector.Collect()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Warn("metrics.cpu.collect.failed", "Failed to collect CPU metrics", map[string]interface{}{
                        "error": err.Error(),
                })
        }</span> else<span class="cov0" title="0"> {
                sample.CPUUtil = cpuUtil
                sample.CPUWatts = cpuWatts
                sample.TempCPU = tempCPU
        }</span>

        // Collect GPU metrics if enabled
        <span class="cov0" title="0">if c.config.EnableGPU &amp;&amp; c.gpuCollector != nil &amp;&amp; c.gpuCollector.IsInitialized() </span><span class="cov0" title="0">{
                gpuUtil, gpuMemMB, gpuWatts, tempGPU, err := c.gpuCollector.Collect()
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("metrics.gpu.collect.failed", "Failed to collect GPU metrics", map[string]interface{}{
                                "error": err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> {
                        sample.GPUUtil = gpuUtil
                        sample.GPUMemMB = gpuMemMB
                        sample.GPUWatts = gpuWatts
                        sample.TempGPU = tempGPU
                }</span>
        }

        // Calculate estimated total power
        <span class="cov0" title="0">estTotal := c.calculateTotalPower(sample)
        sample.EstTotalW = &amp;estTotal

        return sample, nil</span>
}

// calculateTotalPower estimates total system power consumption
func (c *Collector) calculateTotalPower(sample MetricsSample) float64 <span class="cov0" title="0">{
        total := c.config.BaselinePowerW

        if sample.CPUWatts != nil </span><span class="cov0" title="0">{
                total += *sample.CPUWatts
        }</span>

        <span class="cov0" title="0">if sample.GPUWatts != nil </span><span class="cov0" title="0">{
                total += *sample.GPUWatts
        }</span>

        <span class="cov0" title="0">return total</span>
}

// WriteSample writes a sample to the metrics log
func (c *Collector) WriteSample(sample MetricsSample, logPath string) error <span class="cov0" title="0">{
        return c.writer.Write(sample, logPath)
}</span>

// Run starts the metrics collection loop
func (c *Collector) Run(logPath string, stopChan &lt;-chan struct{}) error <span class="cov0" title="0">{
        ticker := time.NewTicker(c.config.SampleInterval)
        defer ticker.Stop()

        c.logger.Info("metrics.collector.start", "Metrics collection started", map[string]interface{}{
                "interval": c.config.SampleInterval.String(),
                "log_path": logPath,
        })

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        sample, err := c.CollectSample()
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("metrics.sample.failed", "Failed to collect sample", map[string]interface{}{
                                        "error": err.Error(),
                                })
                                continue</span>
                        }

                        <span class="cov0" title="0">if err := c.WriteSample(sample, logPath); err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("metrics.write.failed", "Failed to write sample", map[string]interface{}{
                                        "error": err.Error(),
                                })
                        }</span>

                case &lt;-stopChan:<span class="cov0" title="0">
                        c.logger.Info("metrics.collector.stop", "Metrics collection stopped", nil)
                        return nil</span>
                }
        }
}

// Shutdown shuts down the collector
func (c *Collector) Shutdown() <span class="cov0" title="0">{
        if c.gpuCollector != nil </span><span class="cov0" title="0">{
                c.gpuCollector.Shutdown()
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package metrics

import (
        "fmt"
        "os"
        "strconv"
        "strings"
        "time"

        "aistack/internal/logging"
)

// CPUCollector collects CPU metrics
// Story T-012: CPU-Util &amp; RAPL-Leistung erfassen (mit Fallback)
type CPUCollector struct {
        logger          *logging.Logger
        lastStats       *CPUStats
        lastSample      time.Time
        raplEnabled     bool
        raplPath        string
        enablePower     bool
        lastEnergyMicro uint64
        lastEnergyTime  time.Time
        hasEnergySample bool
}

// NewCPUCollector creates a new CPU metrics collector
func NewCPUCollector(logger *logging.Logger, enablePower bool) *CPUCollector <span class="cov8" title="1">{
        collector := &amp;CPUCollector{
                logger:      logger,
                enablePower: enablePower,
        }

        if enablePower </span><span class="cov8" title="1">{
                collector.detectRAPL()
        }</span>

        <span class="cov8" title="1">return collector</span>
}

// detectRAPL checks the filesystem for RAPL support
func (c *CPUCollector) detectRAPL() <span class="cov8" title="1">{
        c.raplPath = "/sys/class/powercap/intel-rapl/intel-rapl:0/energy_uj"
        if _, err := os.Stat(c.raplPath); err == nil </span><span class="cov0" title="0">{
                c.raplEnabled = true
                c.logger.Info("cpu.rapl.detected", "RAPL power monitoring available", map[string]interface{}{
                        "path": c.raplPath,
                })
        }</span> else<span class="cov8" title="1"> {
                c.raplEnabled = false
                c.logger.Info("cpu.rapl.unavailable", "RAPL not available, power metrics disabled", map[string]interface{}{
                        "error": err.Error(),
                })
        }</span>
}

// EnablePowerMetrics toggles RAPL power collection at runtime
func (c *CPUCollector) EnablePowerMetrics(enable bool) <span class="cov0" title="0">{
        c.enablePower = enable
        if enable </span><span class="cov0" title="0">{
                c.detectRAPL()
        }</span>
}

// Collect collects current CPU metrics
func (c *CPUCollector) Collect() (cpuUtil *float64, cpuWatts *float64, tempCPU *float64, err error) <span class="cov0" title="0">{
        // Get current CPU stats
        currentStats, err := c.readCPUStats()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, fmt.Errorf("failed to read CPU stats: %w", err)
        }</span>

        <span class="cov0" title="0">currentTime := time.Now()

        // Calculate utilization if we have previous stats
        if c.lastStats != nil </span><span class="cov0" title="0">{
                util := c.calculateUtilization(c.lastStats, currentStats)
                cpuUtil = &amp;util
        }</span>

        // Get CPU power if enabled and RAPL available
        <span class="cov0" title="0">if c.enablePower &amp;&amp; c.raplEnabled </span><span class="cov0" title="0">{
                watts, err := c.readRAPLWatts(currentTime)
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Warn("cpu.rapl.read.failed", "Failed to read RAPL", map[string]interface{}{
                                "error": err.Error(),
                        })
                }</span> else<span class="cov0" title="0"> if watts != nil </span><span class="cov0" title="0">{
                        cpuWatts = watts
                }</span>
        }

        // TODO: Temperature reading could be added later (hwmon sensors)
        // For now, temperature is optional and left as nil

        // Update state for next collection
        <span class="cov0" title="0">c.lastStats = currentStats
        c.lastSample = currentTime

        return cpuUtil, cpuWatts, tempCPU, nil</span>
}

// readCPUStats reads CPU statistics from /proc/stat
// Story T-012: Delta-basiert aus /proc/stat
func (c *CPUCollector) readCPUStats() (*CPUStats, error) <span class="cov0" title="0">{
        data, err := os.ReadFile("/proc/stat")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read /proc/stat: %w", err)
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(data), "\n")
        if len(lines) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("empty /proc/stat")
        }</span>

        // Parse first line (aggregate CPU stats)
        // Format: cpu user nice system idle iowait irq softirq steal
        <span class="cov0" title="0">fields := strings.Fields(lines[0])
        if len(fields) &lt; 8 || fields[0] != "cpu" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid /proc/stat format")
        }</span>

        <span class="cov0" title="0">stats := &amp;CPUStats{}
        stats.User, _ = strconv.ParseUint(fields[1], 10, 64)
        stats.Nice, _ = strconv.ParseUint(fields[2], 10, 64)
        stats.System, _ = strconv.ParseUint(fields[3], 10, 64)
        stats.Idle, _ = strconv.ParseUint(fields[4], 10, 64)
        stats.IOWait, _ = strconv.ParseUint(fields[5], 10, 64)
        stats.IRQ, _ = strconv.ParseUint(fields[6], 10, 64)
        stats.SoftIRQ, _ = strconv.ParseUint(fields[7], 10, 64)
        if len(fields) &gt; 8 </span><span class="cov0" title="0">{
                stats.Steal, _ = strconv.ParseUint(fields[8], 10, 64)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// calculateUtilization calculates CPU utilization percentage
func (c *CPUCollector) calculateUtilization(prev, current *CPUStats) float64 <span class="cov8" title="1">{
        prevTotal := prev.Total()
        currentTotal := current.Total()
        prevIdle := prev.IdleTime()
        currentIdle := current.IdleTime()

        totalDelta := currentTotal - prevTotal
        idleDelta := currentIdle - prevIdle

        if totalDelta == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        <span class="cov8" title="1">utilization := 100.0 * (1.0 - float64(idleDelta)/float64(totalDelta))

        // Clamp to valid range
        if utilization &lt; 0 </span><span class="cov0" title="0">{
                utilization = 0
        }</span>
        <span class="cov8" title="1">if utilization &gt; 100 </span><span class="cov0" title="0">{
                utilization = 100
        }</span>

        <span class="cov8" title="1">return utilization</span>
}

// readRAPL reads CPU power consumption from RAPL
// Story T-012: RAPL aus /sys/class/powercap
func (c *CPUCollector) readRAPLWatts(now time.Time) (*float64, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(c.raplPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read RAPL: %w", err)
        }</span>

        <span class="cov0" title="0">energyMicrojoules, err := strconv.ParseUint(strings.TrimSpace(string(data)), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse RAPL value: %w", err)
        }</span>

        <span class="cov0" title="0">if !c.hasEnergySample </span><span class="cov0" title="0">{
                c.lastEnergyMicro = energyMicrojoules
                c.lastEnergyTime = now
                c.hasEnergySample = true
                return nil, nil
        }</span>

        // Handle counter rollover
        <span class="cov0" title="0">var deltaEnergy uint64
        if energyMicrojoules &gt;= c.lastEnergyMicro </span><span class="cov0" title="0">{
                deltaEnergy = energyMicrojoules - c.lastEnergyMicro
        }</span> else<span class="cov0" title="0"> {
                // Counter wrapped; reset tracking to avoid bogus negative values
                c.lastEnergyMicro = energyMicrojoules
                c.lastEnergyTime = now
                return nil, nil
        }</span>

        <span class="cov0" title="0">elapsed := now.Sub(c.lastEnergyTime)
        if elapsed &lt;= 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">watts := float64(deltaEnergy) / 1_000_000.0 / elapsed.Seconds()

        c.lastEnergyMicro = energyMicrojoules
        c.lastEnergyTime = now

        return &amp;watts, nil</span>
}

// IsRAPLEnabled returns whether RAPL power monitoring is available
func (c *CPUCollector) IsRAPLEnabled() bool <span class="cov8" title="1">{
        return c.raplEnabled
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package metrics

import (
        "fmt"

        "aistack/internal/gpu"
        "aistack/internal/logging"
        "github.com/NVIDIA/go-nvml/pkg/nvml"
)

// GPUCollector collects GPU metrics using NVML
// Story T-011: GPU-Metriken sammeln (Util/VRAM/Temp/Power)
type GPUCollector struct {
        logger      *logging.Logger
        nvml        gpu.NVMLInterface
        deviceIndex int
        device      gpu.DeviceInterface
        initialized bool
}

// NewGPUCollector creates a new GPU metrics collector
func NewGPUCollector(logger *logging.Logger) *GPUCollector <span class="cov8" title="1">{
        return &amp;GPUCollector{
                logger:      logger,
                nvml:        gpu.NewRealNVML(),
                deviceIndex: 0, // Use first GPU by default
        }
}</span>

// NewGPUCollectorWithNVML creates a collector with custom NVML (for testing)
func NewGPUCollectorWithNVML(nvmlInterface gpu.NVMLInterface, logger *logging.Logger) *GPUCollector <span class="cov8" title="1">{
        return &amp;GPUCollector{
                logger:      logger,
                nvml:        nvmlInterface,
                deviceIndex: 0,
        }
}</span>

// Initialize initializes the GPU collector
func (g *GPUCollector) Initialize() error <span class="cov8" title="1">{
        ret := g.nvml.Init()
        if ret != nvml.SUCCESS </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to initialize NVML: %v", nvml.ErrorString(ret))
        }</span>

        // Get handle to first GPU
        <span class="cov8" title="1">device, ret := g.nvml.DeviceGetHandleByIndex(g.deviceIndex)
        if ret != nvml.SUCCESS </span><span class="cov0" title="0">{
                g.nvml.Shutdown()
                return fmt.Errorf("failed to get GPU device: %v", nvml.ErrorString(ret))
        }</span>

        <span class="cov8" title="1">g.device = device
        g.initialized = true

        g.logger.Info("gpu.collector.initialized", "GPU metrics collector initialized", map[string]interface{}{
                "device_index": g.deviceIndex,
        })

        return nil</span>
}

// Collect collects current GPU metrics
// Story T-011: NVML-Sampling alle 10s, JSONL-Log
func (g *GPUCollector) Collect() (gpuUtil *float64, gpuMemMB *uint64, gpuWatts *float64, tempGPU *float64, err error) <span class="cov8" title="1">{
        if !g.initialized </span><span class="cov8" title="1">{
                return nil, nil, nil, nil, fmt.Errorf("GPU collector not initialized")
        }</span>

        // Get GPU utilization
        <span class="cov8" title="1">utilization, ret := g.device.GetUtilizationRates()
        if ret == nvml.SUCCESS </span><span class="cov8" title="1">{
                util := float64(utilization.Gpu)
                gpuUtil = &amp;util

                // Memory utilization is also in utilization struct
                // but we'll get actual memory usage separately
        }</span> else<span class="cov0" title="0"> {
                g.logger.Warn("gpu.utilization.failed", "Failed to get GPU utilization", map[string]interface{}{
                        "error": nvml.ErrorString(ret),
                })
        }</span>

        // Get memory info
        <span class="cov8" title="1">memInfo, ret := g.device.GetMemoryInfo()
        if ret == nvml.SUCCESS </span><span class="cov8" title="1">{
                usedMB := memInfo.Used / (1024 * 1024)
                gpuMemMB = &amp;usedMB
        }</span> else<span class="cov0" title="0"> {
                g.logger.Warn("gpu.memory.failed", "Failed to get GPU memory", map[string]interface{}{
                        "error": nvml.ErrorString(ret),
                })
        }</span>

        // Get power usage
        <span class="cov8" title="1">powerMilliwatts, ret := g.device.GetPowerUsage()
        if ret == nvml.SUCCESS </span><span class="cov8" title="1">{
                watts := float64(powerMilliwatts) / 1000.0
                gpuWatts = &amp;watts
        }</span> else<span class="cov0" title="0"> {
                g.logger.Warn("gpu.power.failed", "Failed to get GPU power", map[string]interface{}{
                        "error": nvml.ErrorString(ret),
                })
        }</span>

        // Get temperature
        <span class="cov8" title="1">temp, ret := g.device.GetTemperature(nvml.TEMPERATURE_GPU)
        if ret == nvml.SUCCESS </span><span class="cov8" title="1">{
                tempFloat := float64(temp)
                tempGPU = &amp;tempFloat
        }</span> else<span class="cov0" title="0"> {
                g.logger.Warn("gpu.temperature.failed", "Failed to get GPU temperature", map[string]interface{}{
                        "error": nvml.ErrorString(ret),
                })
        }</span>

        <span class="cov8" title="1">return gpuUtil, gpuMemMB, gpuWatts, tempGPU, nil</span>
}

// Shutdown shuts down the GPU collector
func (g *GPUCollector) Shutdown() <span class="cov8" title="1">{
        if g.initialized </span><span class="cov8" title="1">{
                g.nvml.Shutdown()
                g.initialized = false
                g.logger.Info("gpu.collector.shutdown", "GPU metrics collector shut down", nil)
        }</span>
}

// IsInitialized returns whether the collector is initialized
func (g *GPUCollector) IsInitialized() bool <span class="cov8" title="1">{
        return g.initialized
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package metrics

import (
        "time"
)

// MetricsSample represents a single metrics sample
// Data Contract from EP-005: metrics.sample.jsonl
type MetricsSample struct {
        Timestamp time.Time `json:"ts"`
        CPUUtil   *float64  `json:"cpu_util,omitempty"`    // CPU utilization percentage (0-100)
        CPUWatts  *float64  `json:"cpu_w,omitempty"`       // CPU power consumption in watts
        GPUUtil   *float64  `json:"gpu_util,omitempty"`    // GPU utilization percentage (0-100)
        GPUMemMB  *uint64   `json:"gpu_mem,omitempty"`     // GPU memory used in MB
        GPUWatts  *float64  `json:"gpu_w,omitempty"`       // GPU power consumption in watts
        TempCPU   *float64  `json:"temp_cpu,omitempty"`    // CPU temperature in Celsius
        TempGPU   *float64  `json:"temp_gpu,omitempty"`    // GPU temperature in Celsius
        EstTotalW *float64  `json:"est_total_w,omitempty"` // Estimated total power consumption
}

// CPUStats represents CPU statistics from /proc/stat
type CPUStats struct {
        User    uint64
        Nice    uint64
        System  uint64
        Idle    uint64
        IOWait  uint64
        IRQ     uint64
        SoftIRQ uint64
        Steal   uint64
}

// Total returns total CPU time
func (s CPUStats) Total() uint64 <span class="cov8" title="1">{
        return s.User + s.Nice + s.System + s.Idle + s.IOWait + s.IRQ + s.SoftIRQ + s.Steal
}</span>

// Idle returns total idle time
func (s CPUStats) IdleTime() uint64 <span class="cov8" title="1">{
        return s.Idle + s.IOWait
}</span>

// MetricsConfig holds configuration for metrics collection
type MetricsConfig struct {
        SampleInterval time.Duration // How often to collect metrics
        BaselinePowerW float64       // Baseline power consumption (system overhead)
        EnableGPU      bool          // Whether to collect GPU metrics
        EnableCPUPower bool          // Whether to collect CPU power (RAPL)
}

// DefaultConfig returns a default metrics configuration
func DefaultConfig() MetricsConfig <span class="cov8" title="1">{
        return MetricsConfig{
                SampleInterval: 10 * time.Second,
                BaselinePowerW: 50.0, // Conservative baseline for system overhead
                EnableGPU:      true,
                EnableCPUPower: true,
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package metrics

import (
        "encoding/json"
        "fmt"
        "os"

        "aistack/internal/logging"
)

// Writer handles writing metrics samples to JSONL format
type Writer struct {
        logger *logging.Logger
}

// NewWriter creates a new metrics writer
func NewWriter(logger *logging.Logger) *Writer <span class="cov8" title="1">{
        return &amp;Writer{
                logger: logger,
        }
}</span>

// Write writes a metrics sample to a JSONL file
// Story T-011: JSONL-Log
func (w *Writer) Write(sample MetricsSample, filepath string) error <span class="cov8" title="1">{
        // Marshal sample to JSON
        data, err := json.Marshal(sample)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal sample: %w", err)
        }</span>

        // Append newline for JSONL format
        <span class="cov8" title="1">data = append(data, '\n')

        // Open file in append mode (create if not exists)
        file, err := os.OpenFile(filepath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open metrics log: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        // Write sample
        if _, err := file.Write(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write sample: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package services

import (
        "fmt"
        "net/http"
        "time"
)

// HealthStatus represents the health status of a service
type HealthStatus string

const (
        HealthGreen  HealthStatus = "green"
        HealthYellow HealthStatus = "yellow"
        HealthRed    HealthStatus = "red"
)

// HealthCheck represents a health check configuration
type HealthCheck struct {
        URL            string
        Timeout        time.Duration
        ExpectedStatus int
}

// DefaultHealthCheck returns a default health check configuration
func DefaultHealthCheck(url string) HealthCheck <span class="cov8" title="1">{
        return HealthCheck{
                URL:            url,
                Timeout:        10 * time.Second,
                ExpectedStatus: http.StatusOK,
        }
}</span>

// Check performs the health check
func (hc HealthCheck) Check() (HealthStatus, error) <span class="cov8" title="1">{
        client := &amp;http.Client{
                Timeout: hc.Timeout,
        }

        resp, err := client.Get(hc.URL)
        if err != nil </span><span class="cov8" title="1">{
                return HealthRed, fmt.Errorf("health check failed: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != hc.ExpectedStatus </span><span class="cov8" title="1">{
                return HealthYellow, fmt.Errorf("unexpected status code: got %d, want %d", resp.StatusCode, hc.ExpectedStatus)
        }</span>

        <span class="cov8" title="1">return HealthGreen, nil</span>
}

// CheckWithRetries performs health check with retries
func (hc HealthCheck) CheckWithRetries(maxRetries int, retryDelay time.Duration) (HealthStatus, error) <span class="cov8" title="1">{
        var lastErr error

        for i := 0; i &lt; maxRetries; i++ </span><span class="cov8" title="1">{
                status, err := hc.Check()
                if err == nil &amp;&amp; status == HealthGreen </span><span class="cov8" title="1">{
                        return HealthGreen, nil
                }</span>

                <span class="cov8" title="1">lastErr = err
                if i &lt; maxRetries-1 </span><span class="cov8" title="1">{
                        time.Sleep(retryDelay)
                }</span>
        }

        <span class="cov0" title="0">return HealthRed, fmt.Errorf("health check failed after %d retries: %w", maxRetries, lastErr)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package services

import (
        "aistack/internal/logging"
)

// LocalAIService manages the LocalAI container service
// Story T-008: Compose-Template: LocalAI Service (Health &amp; Volume)
type LocalAIService struct {
        *BaseService
}

// NewLocalAIService creates a new LocalAI service
func NewLocalAIService(composeDir string, runtime Runtime, logger *logging.Logger) *LocalAIService <span class="cov8" title="1">{
        healthCheck := DefaultHealthCheck("http://localhost:8080/healthz")
        volumes := []string{"localai_models"}

        base := NewBaseService("localai", composeDir, healthCheck, volumes, runtime, logger)

        return &amp;LocalAIService{
                BaseService: base,
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package services

import (
        "aistack/internal/logging"
        "fmt"
)

// Manager coordinates all services
type Manager struct {
        runtime    Runtime
        logger     *logging.Logger
        composeDir string
        services   map[string]Service
}

// NewManager creates a new service manager
func NewManager(composeDir string, logger *logging.Logger) (*Manager, error) <span class="cov0" title="0">{
        // Detect container runtime
        runtime, err := DetectRuntime()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to detect container runtime: %w", err)
        }</span>

        <span class="cov0" title="0">manager := &amp;Manager{
                runtime:    runtime,
                logger:     logger,
                composeDir: composeDir,
                services:   make(map[string]Service),
        }

        // Register services
        manager.services["ollama"] = NewOllamaService(composeDir, runtime, logger)
        manager.services["openwebui"] = NewOpenWebUIService(composeDir, runtime, logger)
        manager.services["localai"] = NewLocalAIService(composeDir, runtime, logger)

        return manager, nil</span>
}

// GetService returns a service by name
func (m *Manager) GetService(name string) (Service, error) <span class="cov8" title="1">{
        service, exists := m.services[name]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unknown service: %s", name)
        }</span>
        <span class="cov8" title="1">return service, nil</span>
}

// ListServices returns all available service names
func (m *Manager) ListServices() []string <span class="cov8" title="1">{
        names := make([]string, 0, len(m.services))
        for name := range m.services </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

// InstallProfile installs services based on a profile
func (m *Manager) InstallProfile(profile string) error <span class="cov0" title="0">{
        m.logger.Info("profile.install", "Installing profile", map[string]interface{}{
                "profile": profile,
        })

        var servicesToInstall []string

        switch profile </span>{
        case "standard-gpu":<span class="cov0" title="0">
                servicesToInstall = []string{"ollama", "openwebui", "localai"}</span>
        case "minimal":<span class="cov0" title="0">
                servicesToInstall = []string{"ollama"}</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown profile: %s", profile)</span>
        }

        <span class="cov0" title="0">for _, serviceName := range servicesToInstall </span><span class="cov0" title="0">{
                service, err := m.GetService(serviceName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if err := service.Install(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to install %s: %w", serviceName, err)
                }</span>
        }

        <span class="cov0" title="0">m.logger.Info("profile.installed", "Profile installed successfully", map[string]interface{}{
                "profile":  profile,
                "services": servicesToInstall,
        })

        return nil</span>
}

// StatusAll returns status of all services
func (m *Manager) StatusAll() ([]ServiceStatus, error) <span class="cov0" title="0">{
        statuses := make([]ServiceStatus, 0, len(m.services))

        for _, service := range m.services </span><span class="cov0" title="0">{
                status, err := service.Status()
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.Warn("service.status.error", "Failed to get service status", map[string]interface{}{
                                "service": service.Name(),
                                "error":   err.Error(),
                        })
                        continue</span>
                }
                <span class="cov0" title="0">statuses = append(statuses, status)</span>
        }

        <span class="cov0" title="0">return statuses, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package services

import (
        "aistack/internal/logging"
        "fmt"
)

const (
        // AistackNetwork is the name of the common aistack network
        AistackNetwork = "aistack-net"
)

// NetworkManager handles network setup and teardown
type NetworkManager struct {
        runtime Runtime
        logger  *logging.Logger
}

// NewNetworkManager creates a new network manager
func NewNetworkManager(runtime Runtime, logger *logging.Logger) *NetworkManager <span class="cov8" title="1">{
        return &amp;NetworkManager{
                runtime: runtime,
                logger:  logger,
        }
}</span>

// EnsureNetwork creates the aistack network if it doesn't exist (idempotent)
// Story T-005: Compose-Template: Netzwerk &amp; Volumes
func (nm *NetworkManager) EnsureNetwork() error <span class="cov8" title="1">{
        nm.logger.Info("network.ensure", "Ensuring aistack network exists", map[string]interface{}{
                "network": AistackNetwork,
        })

        if err := nm.runtime.CreateNetwork(AistackNetwork); err != nil </span><span class="cov0" title="0">{
                nm.logger.Error("network.create.error", "Failed to create network", map[string]interface{}{
                        "network": AistackNetwork,
                        "error":   err.Error(),
                })
                return fmt.Errorf("failed to ensure network: %w", err)
        }</span>

        <span class="cov8" title="1">nm.logger.Info("network.ready", "Network ready", map[string]interface{}{
                "network": AistackNetwork,
        })

        return nil</span>
}

// EnsureVolumes creates the required volumes if they don't exist (idempotent)
// Story T-005: Compose-Template: Netzwerk &amp; Volumes
func (nm *NetworkManager) EnsureVolumes(volumes []string) error <span class="cov8" title="1">{
        for _, vol := range volumes </span><span class="cov8" title="1">{
                nm.logger.Info("volume.ensure", "Ensuring volume exists", map[string]interface{}{
                        "volume": vol,
                })

                if err := nm.runtime.CreateVolume(vol); err != nil </span><span class="cov0" title="0">{
                        nm.logger.Error("volume.create.error", "Failed to create volume", map[string]interface{}{
                                "volume": vol,
                                "error":  err.Error(),
                        })
                        return fmt.Errorf("failed to ensure volume %s: %w", vol, err)
                }</span>
        }

        <span class="cov8" title="1">nm.logger.Info("volumes.ready", "All volumes ready", map[string]interface{}{
                "count": len(volumes),
        })

        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package services

import (
        "aistack/internal/logging"
)

// OllamaService manages the Ollama container service
// Story T-006: Compose-Template: Ollama Service (Health &amp; Ports)
type OllamaService struct {
        *BaseService
}

// NewOllamaService creates a new Ollama service
func NewOllamaService(composeDir string, runtime Runtime, logger *logging.Logger) *OllamaService <span class="cov8" title="1">{
        healthCheck := DefaultHealthCheck("http://localhost:11434/api/tags")
        volumes := []string{"ollama_data"}

        base := NewBaseService("ollama", composeDir, healthCheck, volumes, runtime, logger)

        return &amp;OllamaService{
                BaseService: base,
        }
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package services

import (
        "aistack/internal/logging"
)

// OpenWebUIService manages the Open WebUI container service
// Story T-007: Compose-Template: Open WebUI mit Backend-Binding
type OpenWebUIService struct {
        *BaseService
}

// NewOpenWebUIService creates a new Open WebUI service
func NewOpenWebUIService(composeDir string, runtime Runtime, logger *logging.Logger) *OpenWebUIService <span class="cov8" title="1">{
        healthCheck := DefaultHealthCheck("http://localhost:3000/")
        volumes := []string{"openwebui_data"}

        base := NewBaseService("openwebui", composeDir, healthCheck, volumes, runtime, logger)

        return &amp;OpenWebUIService{
                BaseService: base,
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package services

import (
        "bytes"
        "fmt"
        "os/exec"
        "strings"
)

// Runtime represents a container runtime (Docker or Podman)
type Runtime interface {
        // ComposeUp starts services defined in a compose file
        ComposeUp(composeFile string, services ...string) error
        // ComposeDown stops and removes services
        ComposeDown(composeFile string) error
        // IsRunning checks if the runtime is available
        IsRunning() bool
        // CreateNetwork creates a network if it doesn't exist
        CreateNetwork(name string) error
        // CreateVolume creates a volume if it doesn't exist
        CreateVolume(name string) error
        // GetContainerStatus returns the status of a container
        GetContainerStatus(name string) (string, error)
}

// DockerRuntime implements Runtime for Docker
type DockerRuntime struct{}

// NewDockerRuntime creates a new Docker runtime
func NewDockerRuntime() *DockerRuntime <span class="cov8" title="1">{
        return &amp;DockerRuntime{}
}</span>

// IsRunning checks if Docker daemon is running
func (r *DockerRuntime) IsRunning() bool <span class="cov8" title="1">{
        cmd := exec.Command("docker", "info")
        return cmd.Run() == nil
}</span>

// ComposeUp starts services using docker compose
func (r *DockerRuntime) ComposeUp(composeFile string, services ...string) error <span class="cov0" title="0">{
        args := []string{"compose", "-f", composeFile, "up", "-d"}
        args = append(args, services...)

        cmd := exec.Command("docker", args...)
        var stderr bytes.Buffer
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("docker compose up failed: %w, stderr: %s", err, stderr.String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ComposeDown stops and removes services
func (r *DockerRuntime) ComposeDown(composeFile string) error <span class="cov0" title="0">{
        cmd := exec.Command("docker", "compose", "-f", composeFile, "down")
        var stderr bytes.Buffer
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("docker compose down failed: %w, stderr: %s", err, stderr.String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateNetwork creates a Docker network if it doesn't exist (idempotent)
func (r *DockerRuntime) CreateNetwork(name string) error <span class="cov0" title="0">{
        // Check if network exists
        checkCmd := exec.Command("docker", "network", "inspect", name)
        if checkCmd.Run() == nil </span><span class="cov0" title="0">{
                // Network already exists
                return nil
        }</span>

        // Create network
        <span class="cov0" title="0">cmd := exec.Command("docker", "network", "create", name)
        var stderr bytes.Buffer
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create network %s: %w, stderr: %s", name, err, stderr.String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateVolume creates a Docker volume if it doesn't exist (idempotent)
func (r *DockerRuntime) CreateVolume(name string) error <span class="cov0" title="0">{
        // Check if volume exists
        checkCmd := exec.Command("docker", "volume", "inspect", name)
        if checkCmd.Run() == nil </span><span class="cov0" title="0">{
                // Volume already exists
                return nil
        }</span>

        // Create volume
        <span class="cov0" title="0">cmd := exec.Command("docker", "volume", "create", name)
        var stderr bytes.Buffer
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create volume %s: %w, stderr: %s", name, err, stderr.String())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetContainerStatus returns the status of a container
func (r *DockerRuntime) GetContainerStatus(name string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("docker", "inspect", "-f", "{{.State.Status}}", name)
        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get container status: %w, stderr: %s", err, stderr.String())
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(stdout.String()), nil</span>
}

// DetectRuntime detects and returns the available container runtime
func DetectRuntime() (Runtime, error) <span class="cov8" title="1">{
        // Check for Docker first (default)
        docker := NewDockerRuntime()
        if docker.IsRunning() </span><span class="cov0" title="0">{
                return docker, nil
        }</span>

        // TODO: Add Podman support in future (EP-003 states Podman is best-effort)

        <span class="cov8" title="1">return nil, fmt.Errorf("no container runtime detected (Docker required)")</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package services

import (
        "aistack/internal/logging"
        "fmt"
        "path/filepath"
)

// Service represents a container service
type Service interface {
        Name() string
        Install() error
        Start() error
        Stop() error
        Status() (ServiceStatus, error)
        Health() (HealthStatus, error)
        Remove(keepData bool) error
}

// ServiceStatus represents the status of a service
type ServiceStatus struct {
        Name    string       `json:"name"`
        State   string       `json:"state"`  // running, stopped, unknown
        Health  HealthStatus `json:"health"` // green, yellow, red
        Message string       `json:"message"`
}

// BaseService provides common service functionality
type BaseService struct {
        name        string
        composeFile string
        healthCheck HealthCheck
        volumes     []string
        runtime     Runtime
        logger      *logging.Logger
        netManager  *NetworkManager
}

// NewBaseService creates a new base service
func NewBaseService(name, composeDir string, healthCheck HealthCheck, volumes []string, runtime Runtime, logger *logging.Logger) *BaseService <span class="cov8" title="1">{
        return &amp;BaseService{
                name:        name,
                composeFile: filepath.Join(composeDir, name+".yaml"),
                healthCheck: healthCheck,
                volumes:     volumes,
                runtime:     runtime,
                logger:      logger,
                netManager:  NewNetworkManager(runtime, logger),
        }
}</span>

// Name returns the service name
func (s *BaseService) Name() string <span class="cov8" title="1">{
        return s.name
}</span>

// Install installs the service (ensures network, volumes, and starts)
func (s *BaseService) Install() error <span class="cov0" title="0">{
        s.logger.Info("service.install.start", fmt.Sprintf("Installing %s service", s.name), map[string]interface{}{
                "service": s.name,
        })

        // Ensure network exists
        if err := s.netManager.EnsureNetwork(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure network: %w", err)
        }</span>

        // Ensure volumes exist
        <span class="cov0" title="0">if err := s.netManager.EnsureVolumes(s.volumes); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure volumes: %w", err)
        }</span>

        // Start the service
        <span class="cov0" title="0">if err := s.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start service: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("service.install.complete", fmt.Sprintf("%s service installed successfully", s.name), map[string]interface{}{
                "service": s.name,
        })

        return nil</span>
}

// Start starts the service using docker compose
func (s *BaseService) Start() error <span class="cov0" title="0">{
        s.logger.Info("service.start", fmt.Sprintf("Starting %s service", s.name), map[string]interface{}{
                "service": s.name,
        })

        if err := s.runtime.ComposeUp(s.composeFile); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("service.start.error", "Failed to start service", map[string]interface{}{
                        "service": s.name,
                        "error":   err.Error(),
                })
                return fmt.Errorf("failed to start %s: %w", s.name, err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("service.started", fmt.Sprintf("%s service started", s.name), map[string]interface{}{
                "service": s.name,
        })

        return nil</span>
}

// Stop stops the service
func (s *BaseService) Stop() error <span class="cov0" title="0">{
        s.logger.Info("service.stop", fmt.Sprintf("Stopping %s service", s.name), map[string]interface{}{
                "service": s.name,
        })

        if err := s.runtime.ComposeDown(s.composeFile); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("service.stop.error", "Failed to stop service", map[string]interface{}{
                        "service": s.name,
                        "error":   err.Error(),
                })
                return fmt.Errorf("failed to stop %s: %w", s.name, err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("service.stopped", fmt.Sprintf("%s service stopped", s.name), map[string]interface{}{
                "service": s.name,
        })

        return nil</span>
}

// Status returns the current status of the service
func (s *BaseService) Status() (ServiceStatus, error) <span class="cov0" title="0">{
        containerName := fmt.Sprintf("aistack-%s", s.name)
        state, err := s.runtime.GetContainerStatus(containerName)
        if err != nil </span><span class="cov0" title="0">{
                return ServiceStatus{
                        Name:    s.name,
                        State:   "unknown",
                        Health:  HealthRed,
                        Message: err.Error(),
                }, nil
        }</span>

        // Get health status
        <span class="cov0" title="0">health := HealthRed
        if state == "running" </span><span class="cov0" title="0">{
                healthStatus, err := s.Health()
                if err == nil </span><span class="cov0" title="0">{
                        health = healthStatus
                }</span>
        }

        <span class="cov0" title="0">return ServiceStatus{
                Name:   s.name,
                State:  state,
                Health: health,
        }, nil</span>
}

// Health performs a health check on the service
func (s *BaseService) Health() (HealthStatus, error) <span class="cov0" title="0">{
        return s.healthCheck.Check()
}</span>

// Remove removes the service (optionally keeping data volumes)
func (s *BaseService) Remove(keepData bool) error <span class="cov0" title="0">{
        s.logger.Info("service.remove", fmt.Sprintf("Removing %s service", s.name), map[string]interface{}{
                "service":   s.name,
                "keep_data": keepData,
        })

        // First stop the service
        if err := s.Stop(); err != nil </span><span class="cov0" title="0">{
                // Log but continue - service might already be stopped
                s.logger.Warn("service.remove.stop_error", "Error stopping service during removal", map[string]interface{}{
                        "service": s.name,
                        "error":   err.Error(),
                })
        }</span>

        // TODO: If !keepData, remove volumes
        // This would require additional runtime methods for volume removal

        <span class="cov0" title="0">s.logger.Info("service.removed", fmt.Sprintf("%s service removed", s.name), map[string]interface{}{
                "service": s.name,
        })

        return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package tui

import (
        "fmt"
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// Model represents the TUI application state
type Model struct {
        startTime time.Time
        quitting  bool
}

// NewModel creates a new TUI model
func NewModel() Model <span class="cov8" title="1">{
        return Model{
                startTime: time.Now(),
                quitting:  false,
        }
}</span>

// Init initializes the model
func (m Model) Init() tea.Cmd <span class="cov8" title="1">{
        return nil
}</span>

// Update handles messages and updates the model
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov8" title="1">
                switch msg.String() </span>{
                case "q", "ctrl+c":<span class="cov8" title="1">
                        m.quitting = true
                        return m, tea.Quit</span>
                }
        }
        <span class="cov8" title="1">return m, nil</span>
}

// View renders the TUI
func (m Model) View() string <span class="cov8" title="1">{
        if m.quitting </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Define styles using Lip Gloss
        <span class="cov8" title="1">titleStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(lipgloss.Color("#00d7ff")).
                PaddingTop(1).
                PaddingBottom(1)

        subtitleStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("#808080"))

        helpStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("#626262")).
                PaddingTop(1)

        // Build the view
        title := titleStyle.Render("aistack")
        subtitle := subtitleStyle.Render("AI Stack Manager - TUI Interface")
        help := helpStyle.Render("Press 'q' or Ctrl+C to quit")

        return fmt.Sprintf("\n%s\n%s\n\n%s\n", title, subtitle, help)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
